

#Область ПрограммныйИнтерфейс

// Проверяет существование структуры дерева в регистре для указанного шаблона
Функция СуществуетСтруктураДереваВРегистре(СсылкаНаШаблон) Экспорт
    
    Если СсылкаНаШаблон = Неопределено Тогда
        Возврат Ложь;
    КонецЕсли;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    КОЛИЧЕСТВО(*) КАК КоличествоЗаписей
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК СтруктураБинарногоДерева
    |ГДЕ
    |    СтруктураБинарногоДерева.ШаблонТеста = &ШаблонТеста";
    
    Запрос.УстановитьПараметр("ШаблонТеста", СсылкаНаШаблон);
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Возврат Выборка.КоличествоЗаписей > 0;
    КонецЕсли;
    
    Возврат Ложь;
    
КонецФункции

Функция ПроверитьЦелостностьДереваВРегистре(Шаблон) Экспорт
    
    РезультатПроверки = Новый Структура;
    РезультатПроверки.Вставить("ПроверкаПройдена", Истина);
    РезультатПроверки.Вставить("СообщениеОбОшибке", "");

    // Проверка 1: Ищем "битые" ссылки (записи в регистре, ссылающиеся на удаленные узлы)
    Запрос = Новый Запрос;
    Запрос.Текст =
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    1 КАК ЕстьПроблема
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
    |        ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК Родители
    |        ПО Структура.РодительскийУзел = Родители.Ссылка
    |        ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК Дети
    |        ПО Структура.СледующийУзелДерева = Дети.Ссылка
    |ГДЕ
    |    Структура.ШаблонТеста = &Шаблон
    |    И (Родители.Ссылка ЕСТЬ NULL И Структура.РодительскийУзел <> ЗНАЧЕНИЕ(Справочник.УзлыБинарногоДерева.ПустаяСсылка)
    |            ИЛИ Дети.Ссылка ЕСТЬ NULL)";
    
    Запрос.УстановитьПараметр("Шаблон", Шаблон);
    Если НЕ Запрос.Выполнить().Пустой() Тогда
        РезультатПроверки.ПроверкаПройдена = Ложь;
        РезультатПроверки.СообщениеОбОшибке = "Обнаружены 'битые' ссылки. Есть записи в регистре, которые ссылаются на удаленные узлы.";
        Возврат РезультатПроверки;
    КонецЕсли;

    // Проверка 2: Ищем количество корневых узлов (должен быть ровно 1)
    Запрос.Текст =
    "ВЫБРАТЬ
    |    КОЛИЧЕСТВО(Структура.СледующийУзелДерева) КАК КоличествоКорней
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
    |ГДЕ
    |    Структура.ШаблонТеста = &Шаблон
    |    И Структура.РодительскийУзел = ЗНАЧЕНИЕ(Справочник.УзлыБинарногоДерева.ПустаяСсылка)";
        
    Выборка = Запрос.Выполнить().Выбрать();
    Выборка.Следующий();
    
    Если Выборка.КоличествоКорней = 0 Тогда
        РезультатПроверки.ПроверкаПройдена = Ложь;
        РезультатПроверки.СообщениеОбОшибке = "Целостность нарушена: не найден корневой узел (узел без родителя).";
        Возврат РезультатПроверки;
    ИначеЕсли Выборка.КоличествоКорней > 1 Тогда
        РезультатПроверки.ПроверкаПройдена = Ложь;
        РезультатПроверки.СообщениеОбОшибке = "Целостность нарушена: найдено более одного корневого узла (" + Выборка.КоличествоКорней + ").";
        Возврат РезультатПроверки;
    КонецЕсли;

    Возврат РезультатПроверки;

КонецФункции

// Создает структуру бинарного дерева в документе теста
Процедура СоздатьСтруктуруДереваВТесте(Тест) Экспорт
	
	// Очищаем существующую структуру
	Тест.СтруктураДереваТеста.Очистить();
	
	// Создаем новую структуру дерева "Угадай животное"
	СоздатьДеревоУгадайЖивотное(Тест);
	
КонецПроцедуры

// Получает все узлы дерева из справочника
Функция ПолучитьВсеУзлыДерева() Экспорт
	
	Узлы = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УзлыБинарногоДерева.Ссылка,
	|	УзлыБинарногоДерева.Наименование,
	|	УзлыБинарногоДерева.Вопрос,
	|	УзлыБинарногоДерева.ЯвляетсяЛистом,
	|	УзлыБинарногоДерева.Уровень
	|ИЗ
	|	Справочник.УзлыБинарногоДерева КАК УзлыБинарногоДерева";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Узлы.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
	Возврат Узлы;
	
КонецФункции

// Создает связи для узла в тесте
Процедура СоздатьСвязиДляУзлаВТесте(Тест, Узел) Экспорт
	
	// Получаем связи узла из регистра или другого источника
	СвязиУзла = ПолучитьСвязиУзла(Узел);
	
	Для Каждого Связь Из СвязиУзла Цикл
		// Добавляем запись в табличную часть теста
		НоваяСтрока = Тест.СтруктураДереваТеста.Добавить();
		НоваяСтрока.УзелДерева = Связь.УзелДерева.Ссылка;
		НоваяСтрока.РодительскийУзел = Связь.РодительскийУзел;
		НоваяСтрока.ТипСвязи = Связь.ТипСвязи;
		НоваяСтрока.Вопрос = Связь.Вопрос;
		НоваяСтрока.Уровень = Связь.Уровень;
		НоваяСтрока.ЯвляетсяЛистом = Связь.ЯвляетсяЛистом;
		НоваяСтрока.Порядок = Связь.Порядок;
		НоваяСтрока.Активность = Истина;
	КонецЦикла;
	
КонецПроцедуры

// Получает связи для узла (заглушка - нужно реализовать логику получения связей)
Функция ПолучитьСвязиУзла(Узел) Экспорт
	
	Связи = Новый Массив;
	
	// Здесь должна быть логика получения связей узла
	// Например, из регистра, из предопределенных структур и т.д.
	// Временная заглушка:
	
	Если Узел.Уровень = 0 Тогда
		// Корневой узел
		Связь = Новый Структура;
		Связь.Вставить("УзелДерева", Узел);
		Связь.Вставить("РодительскийУзел", Неопределено);
		Связь.Вставить("ТипСвязи", Неопределено);
		Связь.Вставить("Вопрос", Узел.Вопрос);
		Связь.Вставить("Уровень", 0);
		Связь.Вставить("ЯвляетсяЛистом", Ложь);
		Связь.Вставить("Порядок", 1);
		Связи.Добавить(Связь);
	КонецЕсли;
	
	Возврат Связи;
	
КонецФункции

// Модуль объекта документа ТестБинарноеДерево

#Область ОсновныеПроцедуры

// Обновленная процедура обработки ответа с безопасной работой
Процедура ОбработатьОтветВРегистре(СсылкаНаТест, Ответ) Экспорт
    
    // ⭐ УСИЛЕННОЕ ПОЛУЧЕНИЕ ОБЪЕКТА ТЕСТА
    Попытка
        Тест = СсылкаНаТест.ПолучитьОбъект();
    Исключение
        Сообщить("   КРИТИЧЕСКАЯ ОШИБКА: Не удалось получить объект теста!");
        Возврат;
    КонецПопытки;
    
    Сообщить("=== ОБРАБОТКА ОТВЕТА ===");
    Сообщить("   Текущий узел: " + ?(Тест.ТекущийУзелДерева = Неопределено, "Неопределено", 
        Тест.ТекущийУзелДерева.Наименование));
    Сообщить("   Ответ: " + Ответ);
    
    // ⭐ УСИЛЕННАЯ ПРОВЕРКА ТЕКУЩЕГО УЗЛА С ВОССТАНОВЛЕНИЕМ
    Если Тест.ТекущийУзелДерева = Неопределено Тогда
        Сообщить("   ВНИМАНИЕ: Текущий узел не установлен. Пытаемся восстановить...");
        
        // Пытаемся восстановить корневой узел
        КорневойУзел = НайтиКорневойУзел(Тест);
        Если КорневойУзел <> Неопределено Тогда
            Тест.ТекущийУзелДерева = КорневойУзел;
            Сообщить("   ✓ Восстановлен текущий узел: " + КорневойУзел.Наименование);
        Иначе
            Сообщить("   ОШИБКА: Не удалось восстановить текущий узел! Завершаем тест.");
            Тест.Завершен = Истина;
            Тест.ВремяЗавершения = ТекущаяДата();
            Тест.РезультатСдачи = Перечисления.РезультатыСдачи.НеСдан;
            Тест.ПроцентЗавершения = 0;
            Попытка
                Тест.Записать();
            Исключение
                Сообщить("   Ошибка при сохранении теста: " + ОписаниеОшибки());
            КонецПопытки;
            Возврат;
        КонецЕсли;
    КонецЕсли; 	
    Если Тест.Завершен Тогда
        Сообщить("   Тест уже завершен");
        Возврат;
    КонецЕсли;
    
    ТекущийУзел = Тест.ТекущийУзелДерева;
    
    Если ТекущийУзел = Неопределено Тогда
        Сообщить("   ОШИБКА: Не установлен текущий узел!");
        Возврат;
    КонецЕсли;
    
    // Безопасное обновление базы знаний
    БезопасноОбновитьБазуЗнанийПриОтвете(Тест, ТекущийУзел, Ответ);
    
    // Находим следующий узел
    СледующийУзел = НайтиСледующийУзелИзРегистра(Тест, ТекущийУзел, Ответ);
    Сообщить("   Следующий узел: " + ?(СледующийУзел = Неопределено, "Неопределен", СледующийУзел.Наименование + ", ЯвляетсяЛистом: " + СледующийУзел.ЯвляетсяЛистом));
    
    // Записываем ответ
    ЗаписатьОтветПользователя(Тест, ТекущийУзел, Ответ);
    
    // Переходим к следующему вопросу
    ЗаписатьТекущийВопрос(Тест, СледующийУзел);
    ОбновитьСтатистикуТеста(Тест);
    
    // Сохраняем в регистры
    СохранитьОтветыВРегистр(Тест);
    СохранитьСостояниеТестаВРегистр(Тест);
    
    // ⭐ ВАЖНО: Сохраняем тест после всех изменений
    Попытка
        Тест.Записать();
        Сообщить("   Тест успешно сохранен");
    Исключение
        Сообщить("   ОШИБКА при сохранении теста: " + ОписаниеОшибки());
        ВызватьИсключение;
    КонецПопытки;
    
    Сообщить("   База знаний обновлена для узла: " + ТекущийУзел.Наименование);
    
КонецПроцедуры

Процедура ОбработатьОтвет(СсылкаНаТест, Ответ) Экспорт
    
    Тест = СсылкаНаТест.ПолучитьОбъект();
    
    Сообщить("=== ОБРАБОТКА ОТВЕТА ===");
    Сообщить("   Текущий узел: " + ?(Тест.ТекущийУзелДерева = Неопределено, "Неопределено", 
        Тест.ТекущийУзелДерева.Наименование));
    Сообщить("   Ответ: " + Ответ);
    
    Если Тест.Завершен Тогда
        Сообщить("   Тест уже завершен");
        Возврат;
    КонецЕсли;
    
    ТекущийУзел = Тест.ТекущийУзелДерева;
    
    Если ТекущийУзел = Неопределено Тогда
        Сообщить("   ОШИБКА: Не установлен текущий узел!");
        Возврат;
    КонецЕсли;
    
    // Безопасное обновление базы знаний
    БезопасноОбновитьБазуЗнанийПриОтвете(Тест, ТекущийУзел, Ответ);
    
    // ⭐ ИСПОЛЬЗУЕМ ФУНКЦИЮ ДЛЯ ПОИСКА В ДОКУМЕНТЕ
    СледующийУзел = НайтиСледующийУзелИзДокумента(Тест, ТекущийУзел, Ответ);
    Сообщить("   Следующий узел: " + ?(СледующийУзел = Неопределено, "Неопределен", СледующийУзел.Наименование + ", ЯвляетсяЛистом: " + СледующийУзел.ЯвляетсяЛистом));
    
    // Записываем ответ
    ЗаписатьОтветПользователя(Тест, ТекущийУзел, Ответ);
    
    // Переходим к следующему вопросу
    ЗаписатьТекущийВопрос(Тест, СледующийУзел);
    ОбновитьСтатистикуТеста(Тест);
    
    // Сохраняем в регистры
    СохранитьОтветыВРегистр(Тест);
    СохранитьСостояниеТестаВРегистр(Тест);
    
    // Сохраняем тест после всех изменений
    Попытка
        Тест.Записать();
        Сообщить("   Тест успешно сохранен");
    Исключение
        Сообщить("   ОШИБКА при сохранении теста: " + ОписаниеОшибки());
        ВызватьИсключение;
    КонецПопытки;
    
    Сообщить("   База знаний обновлена для узла: " + ТекущийУзел.Наименование);
    
КонецПроцедуры

// Безопасное обновление базы знаний
Процедура БезопасноОбновитьБазуЗнанийПриОтвете(Тест, Узел, Ответ) Экспорт
    
    Если Узел = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    Если НЕ РегистрБазаЗнанийСуществует() Тогда
        Сообщить("   ⚠️ База знаний недоступна, пропускаем обновление");
        Возврат;
    КонецЕсли;
    
    // Рассчитываем правильность (для бинарного дерева - 1 если достигнут лист)
    Правильность = ?(Узел.ЯвляетсяЛистом, 1, 0);
    
    // Добавляем в базу знаний
    БезопасноДобавитьВБазуЗнаний(Тест, Узел, Ответ, Правильность);
    
КонецПроцедуры

// Инициализирует тест, который УЖЕ заполнен структурой из шаблона
Процедура ИнициализироватьБинарноеДеревоДляТеста(Тест) Экспорт
	
    Если Тест.СтруктураДереваТеста.Количество() = 0 Тогда
        Сообщить("ДИАГНОСТИКА: Структура дерева пустая!");
        Сообщить("   Шаблон теста: " + ?(Тест.ШаблонТеста = Неопределено, "Неопределено", Тест.ШаблонТеста.Наименование));
        Сообщить("   Тип тестирования: " + Тест.ТипТестирования);
        ВызватьИсключение "Ошибка инициализации: структура дерева в документе пуста.";
    КонецЕсли;

	Сообщить("   Инициализация теста: Поиск корневого узла в готовой структуре...");
	Сообщить("   Всего строк в структуре: " + Тест.СтруктураДереваТеста.Количество());
	
    // Выводим информацию о первых нескольких узлах для диагностики
    Счетчик = 0;
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Если Счетчик < 5 Тогда // Показываем только первые 5 узлов
            Сообщить("   Узел " + Счетчик + ": " + 
                ?(СтрокаСтруктуры.УзелДерева = Неопределено, "НЕОПР", СтрокаСтруктуры.УзелДерева.Наименование) + 
                ", Родитель: " + ?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "КОРЕНЬ", СтрокаСтруктуры.РодительскийУзел.Наименование));
        КонецЕсли;
        Счетчик = Счетчик + 1;
    КонецЦикла;
	
    КорневойУзелСсылка = НайтиКорневойУзел(Тест);
	
	Если КорневойУзелСсылка = Неопределено ИЛИ КорневойУзелСсылка.Пустая() Тогда
        Сообщить("ДИАГНОСТИКА: Не удалось найти корневой узел!");
        // Показываем все узлы для диагностики
        Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
            Сообщить("   Узел: " + ?(СтрокаСтруктуры.УзелДерева = Неопределено, "НЕОПР", СтрокаСтруктуры.УзелДерева.Наименование) + 
                    ", Родитель: " + ?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "КОРЕНЬ", СтрокаСтруктуры.РодительскийУзел.Наименование) +
                    ", Активность: " + СтрокаСтруктуры.Активность);
        КонецЦикла;
		ВызватьИсключение "Ошибка инициализации: Не удалось найти корневой узел в структуре теста! Убедитесь, что в шаблоне есть узел без родителя.";
	КонецЕсли;
	
	Тест.ТекущийУзелДерева = КорневойУзелСсылка;
	
	// Сбрасываем состояние теста к начальному
	Тест.ОтветыБинарногоДерева.Очистить();
    Тест.ВопросыБинарногоДерева.Очистить();
    Тест.КоличествоВопросов = 0;
    Тест.Завершен = Ложь;
    Тест.РезультатСдачи = Перечисления.РезультатыСдачи.ПустаяСсылка();
    Тест.ПроцентЗавершения = 0;
    Тест.ВремяЗавершения = Неопределено;

	Сообщить("   ✓ Тест инициализирован. Текущий узел установлен: " + Тест.ТекущийУзелДерева);
	
КонецПроцедуры

// Создает корневой узел для теста
Функция СоздатьКорневойУзел(Тест) Экспорт
	
	// Создаем корневой вопрос
	КорневойВопрос = СоздатьВопрос("Оно живет в воде?", "Определяет среду обитания животного");
	КорневойУзел = СоздатьУзел("Корневой узел - среда обитания", КорневойВопрос);
	
	// Записываем корневой узел в табличную часть теста
	ЗаписатьУзелДереваВТест(Тест, Неопределено, Неопределено, КорневойУзел, КорневойВопрос, Ложь);
	
	// Обязательно записываем тест
	Тест.Записать();
	
	Сообщить("   ✓ Создан новый корневой узел: " + КорневойУзел.Наименование);
	
	Возврат КорневойУзел;
	
КонецФункции

// Исправленная функция поиска корневого узла
Функция НайтиКорневойУзел(Тест) Экспорт
    
    Сообщить("   Поиск корневого узла в табличной части...");
    Сообщить("   Всего строк в структуре: " + Тест.СтруктураДереваТеста.Количество());
    
    // Ищем корневой узел (без родителя) в табличной части теста
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Сообщить("   Проверка строки: Родитель=" + ?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "НЕОПР", 
                СтрокаСтруктуры.РодительскийУзел.Наименование) + 
                ", Узел=" + ?(СтрокаСтруктуры.УзелДерева = Неопределено, "ПУСТОЙ", 
                СтрокаСтруктуры.УзелДерева.Наименование));
				
		//тут		
		Если (СтрокаСтруктуры.РодительскийУзел = Неопределено 
		ИЛИ СтрокаСтруктуры.РодительскийУзел.Пустая())
		И СтрокаСтруктуры.УзелДерева <> Неопределено 
		И СтрокаСтруктуры.Активность Тогда
            Сообщить("   Найден корневой узел: " + СтрокаСтруктуры.УзелДерева.Наименование);
            Возврат СтрокаСтруктуры.УзелДерева;
        КонецЕсли;
    КонецЦикла;
    
    Сообщить("   ВНИМАНИЕ: Корневой узел не найден в табличной части теста");
    
    // Пробуем найти любой узел с уровнем 0
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Если СтрокаСтруктуры.УзелДерева <> Неопределено 
           И СтрокаСтруктуры.Уровень = 0 
           И СтрокаСтруктуры.Активность Тогда
            Сообщить("   Найден узел уровня 0: " + СтрокаСтруктуры.УзелДерева.Наименование);
            Возврат СтрокаСтруктуры.УзелДерева;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Неопределено;
    
КонецФункции

// Диагностическая функция для снимка табличной части
Процедура СнимокТабличнойЧасти(Тест, Сообщение = "") Экспорт
    
    Сообщить("=== СНИМОК ТАБЛИЧНОЙ ЧАСТИ: " + Сообщение + " ===");
    Сообщить("Количество строк: " + Тест.СтруктураДереваТеста.Количество());
    
    Для Каждого Строка Из Тест.СтруктураДереваТеста Цикл
        Сообщить("--- Строка " + Строка.НомерСтроки + " ---");
        
        // Диагностика УзелДерева
        Если Строка.УзелДерева = Неопределено Тогда
            Сообщить("УзелДерева: НЕОПРЕДЕЛЕНО");
        Иначе
            Попытка
                Сообщить("УзелДерева: " + Строка.УзелДерева.Наименование + 
                        " (Ссылка: " + Строка.УзелДерева + ")");
            Исключение
                Сообщить("УзелДерева: ОШИБКА чтения - " + ОписаниеОшибки());
            КонецПопытки;
        КонецЕсли;
        
        // Диагностика РодительскийУзел
        Если Строка.РодительскийУзел = Неопределено Тогда
            Сообщить("РодительскийУзел: НЕОПРЕДЕЛЕНО");
        Иначе
            Попытка
                Сообщить("РодительскийУзел: " + Строка.РодительскийУзел.Наименование);
            Исключение
                Сообщить("РодительскийУзел: ОШИБКА чтения");
            КонецПопытки;
        КонецЕсли;
        
        Сообщить("ТипСвязи: " + Строка.ТипСвязи);
        Сообщить("Уровень: " + Строка.Уровень);
        Сообщить("Активность: " + Строка.Активность);
    КонецЦикла;
    
    Сообщить("=== КОНЕЦ СНИМКА ===");
    
КонецПроцедуры

// Диагностическая функция для снимка узла
Процедура СнимокУзла(Узел, Сообщение = "") Экспорт
    
    Сообщить("=== СНИМОК УЗЛА: " + Сообщение + " ===");
    
    Если Узел = Неопределено Тогда
        Сообщить("Узел: НЕОПРЕДЕЛЕНО");
        Возврат;
    КонецЕсли;
    
    Попытка
        Сообщить("Наименование: " + Узел.Наименование);
        Сообщить("Ссылка: " + Узел.Ссылка);
        Сообщить("Пустая ссылка: " + Узел.Ссылка.Пустая());
        Сообщить("ЯвляетсяЛистом: " + Узел.ЯвляетсяЛистом);
        Сообщить("Уровень: " + Узел.Уровень);
        
        Если Узел.Вопрос = Неопределено Тогда
            Сообщить("Вопрос: НЕОПРЕДЕЛЕНО");
        Иначе
            Сообщить("Вопрос: " + Узел.Вопрос.Наименование);
        КонецЕсли;
        
    Исключение
        Сообщить("ОШИБКА чтения узла: " + ОписаниеОшибки());
    КонецПопытки;
    
    Сообщить("=== КОНЕЦ СНИМКА ===");
    
КонецПроцедуры
	
// ДОБАВЛЯЕМ в начало ЗаписатьУзелДереваВТест:
Процедура ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, ТипСвязи, УзелДерева, Вопрос, ЯвляетсяЛистом) Экспорт

	// Проверяем, что узел не пустой
    Если УзелДерева = Неопределено Тогда
        Сообщить("   ОШИБКА: Попытка добавить пустой узел в структуру!");
        ВызватьИсключение "ОШИБКА: Попытка добавить пустой узел в структуру дерева!";
    КонецЕсли;
    // ВАЛИДАЦИЯ: Проверяем что вопрос не пустой и записан в базу
    Если Вопрос = Неопределено Тогда
        ВызватьИсключение "ОШИБКА: Попытка добавить пустой вопрос в структуру дерева!";
    КонецЕсли;
    Если СокрЛП(Вопрос) = "" Тогда
        ВызватьИсключение "ОШИБКА: Попытка добавить пустой вопрос в структуру дерева!";
    КонецЕсли;
    
    // ОБЯЗАТЕЛЬНО записываем узел если он новый
    // ДОБАВИТЬ ЭТУ ПРОВЕРКУ - убедимся что узел записан в справочник
    Если УзелДерева.Ссылка.Пустая() Тогда
        Сообщить("   Узел не записан в справочник! Записываем...");
        УзелДерева.Записать();
    КонецЕсли;
    
    // ОБЯЗАТЕЛЬНО записываем вопрос если он новый  
    Если Вопрос.Ссылка.Пустая() Тогда
        Вопрос.Записать();
    КонецЕсли;	

	СнимокУзла(УзелДерева, "Перед записью в табличную часть");
	
    // Добавляем запись в табличную часть теста
    НоваяСтрока = Тест.СтруктураДереваТеста.Добавить();
    НоваяСтрока.УзелДерева = УзелДерева.Ссылка;
	
	// Добавь эти проверки в отладчике:
	Сообщить("Тип УзелДерева: " + ТипЗнч(УзелДерева));
	Сообщить("УзелДерева = Неопределено: " + (УзелДерева = Неопределено));
	Если УзелДерева <> Неопределено Тогда
	    Сообщить("УзелДерева.Ссылка: " + УзелДерева.Ссылка);
	    Сообщить("УзелДерева.Ссылка.Пустая(): " + УзелДерева.Ссылка.Пустая());
	    Сообщить("УзелДерева.Наименование: " + УзелДерева.Наименование);
	КонецЕсли;	
	
	Если РодительскийУзел <> Неопределено Тогда
	    Если ТипЗнч(РодительскийУзел) = Тип("СправочникОбъект.УзлыБинарногоДерева") Тогда
	        РодительскийУзел = РодительскийУзел.Ссылка;  // Преобразуем в ссылку
	    КонецЕсли;
	    Если НЕ РодительскийУзел.Пустая() Тогда
	        НоваяСтрока.РодительскийУзел = РодительскийУзел;
	    КонецЕсли;
	КонецЕсли;
	
    НоваяСтрока.ТипСвязи = ТипСвязи;
    НоваяСтрока.Вопрос = Вопрос.Ссылка;
    НоваяСтрока.ЯвляетсяЛистом = ЯвляетсяЛистом;
    НоваяСтрока.Активность = Истина;
    
    // Рассчитываем уровень
    Если РодительскийУзел = Неопределено Тогда
        НоваяСтрока.Уровень = 0; // Корневой узел
        Сообщить("   Добавлен корневой узел: " + УзелДерева.Наименование);
    Иначе
        // Находим уровень родителя и увеличиваем на 1
        УровеньРодителя = 0;
        Для Каждого СуществующаяСтрока Из Тест.СтруктураДереваТеста Цикл
            Если СуществующаяСтрока.УзелДерева = РодительскийУзел Тогда
                УровеньРодителя = СуществующаяСтрока.Уровень;
                Прервать;
            КонецЕсли;
        КонецЦикла;
        НоваяСтрока.Уровень = УровеньРодителя + 1;
        Сообщить("   Добавлен узел: " + РодительскийУзел.Наименование + 
                " -> " + УзелДерева.Наименование + " (" + ТипСвязи + ", уровень: " + НоваяСтрока.Уровень + ")");
	КонецЕсли; 
	
   // НЕМЕДЛЕННАЯ ПРОВЕРКА после добавления
    Если НоваяСтрока.УзелДерева.Пустая() Тогда
        ВызватьИсключение "КРИТИЧЕСКАЯ ОШИБКА: В табличной части создана строка с пустой ссылкой на узел!";
    КонецЕсли;
	
    СнимокТабличнойЧасти(Тест, "После добавления узла " + УзелДерева.Наименование);
КонецПроцедуры

Процедура ОчиститьТестовыеДанные() Экспорт
    ВыборкаУзлы = Справочники.УзлыБинарногоДерева.Выбрать();
    Пока ВыборкаУзлы.Следующий() Цикл
        Если СтрНайти(ВыборкаУзлы.Наименование, "Узел") > 0 Тогда  // Фильтр по тестовым
            УзелОбъект = ВыборкаУзлы.ПолучитьОбъект();
            УзелОбъект.Удалить();
        КонецЕсли;
    КонецЦикла;
    // Аналогично для вопросов
КонецПроцедуры

Процедура ОчиститьТестовыеДанныеПолностью() Экспорт 
	// Узлы
	ЗапросУзлы = Новый Запрос;
	ЗапросУзлы.Текст = "ВЫБРАТЬ Ссылка ИЗ Справочник.УзлыБинарногоДерева";
	Выборка = ЗапросУзлы.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.Удалить();
	КонецЦикла;
	
	// Вопросы
	ЗапросВопросы = Новый Запрос;
	ЗапросВопросы.Текст = "ВЫБРАТЬ Ссылка ИЗ ПланВидовХарактеристик.ВопросыДляТестирования";
	Выборка = ЗапросВопросы.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.Удалить();
	КонецЦикла;
	
	Сообщить("   Тестовые данные полностью очищены");
КонецПроцедуры

Функция СоздатьУзел(НаименованиеУзла, Вопрос) Экспорт
	
	Если СтрДлина(НаименованиеУзла) > 149 Тогда
        Сообщить("   ОШИБКА: Длина наименования узла не может превышать 149 символов!");
        Сообщить("   Получено: " + СтрДлина(НаименованиеУзла) + " символов, поиск не будет работать с длинным наименованием");
        Сообщить("   Наименование: " + Лев(НаименованиеУзла, 149) + "...");
        Возврат Неопределено;
    КонецЕсли;	
	
	
    // ПРОВЕРКА УНИКАЛЬНОСТИ ПЕРЕД СОЗДАНИЕМ
    СуществующийУзел = НайтиУзелПоНаименованию(НаименованиеУзла);
    Если СуществующийУзел <> Неопределено Тогда
        Сообщить("   Узел уже существует: " + НаименованиеУзла);
        Возврат СуществующийУзел;
    КонецЕсли;
    
    Попытка
        НовыйУзел = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        НовыйУзел.Наименование = НаименованиеУзла;
        НовыйУзел.Вопрос = Вопрос.Ссылка;
        НовыйУзел.ЯвляетсяЛистом = Ложь;
        НовыйУзел.Уровень = 0;
        
        // ПРОВЕРКА УНИКАЛЬНОСТИ ПЕРЕД ЗАПИСЬЮ
        Если Не ПроверитьУникальностьУзла(НовыйУзел) Тогда
            Сообщить("   ОШИБКА: Узел с таким наименованием уже существует!");
            Возврат Неопределено;
        КонецЕсли;
        
        НовыйУзел.Записать();
        
        Сообщить("   ✓ Создан узел: " + НаименованиеУзла);
        
        Возврат НовыйУзел;
        
    Исключение
        Сообщить("   ОШИБКА при создании узла '" + НаименованиеУзла + "': " + ОписаниеОшибки());
        Возврат Неопределено;
    КонецПопытки;
    
КонецФункции

// Поиск вопроса по тексту формулировки
Функция НайтиВопросПоТексту(ТекстВопроса) Экспорт
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    Вопросы.Ссылка
    |ИЗ
    |    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы
    |ГДЕ
    |    Вопросы.ТекстФормулировки ПОДОБНО &ТекстВопроса";
    
    Запрос.УстановитьПараметр("ТекстВопроса", ТекстВопроса);
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Возврат Выборка.Ссылка.ПолучитьОбъект();
    КонецЕсли;
    
    Возврат Неопределено;
    
КонецФункции

// Поиск узла по наименованию
Функция НайтиУзелПоНаименованию(НаименованиеУзла) Экспорт
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    Узлы.Ссылка
    |ИЗ
    |    Справочник.УзлыБинарногоДерева КАК Узлы
    |ГДЕ
    |    Узлы.Наименование ПОДОБНО ""%"+НаименованиеУзла+"%""";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Возврат Выборка.Ссылка.ПолучитьОбъект();
    КонецЕсли;
    
    Возврат Неопределено;
    
КонецФункции

// Детальная проверка уникальности вопроса
Функция ПроверитьУникальностьВопроса(Вопрос) Экспорт
    
    Запрос = Новый Запрос;
    
    Если Вопрос.Ссылка.Пустая() Тогда
        // Для новых объектов - проверяем только по тексту
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    Вопросы.Ссылка
        |ИЗ
        |    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы
        |ГДЕ
        |    Вопросы.ТекстФормулировки ПОДОБНО &ТекстВопроса";
    Иначе
        // Для существующих объектов - исключаем текущий вопрос
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    Вопросы.Ссылка
        |ИЗ
        |    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы
        |ГДЕ
        |    Вопросы.ТекстФормулировки ПОДОБНО &ТекстВопроса
        |    И Вопросы.Ссылка <> &ТекущийВопрос";
    КонецЕсли;
    
    Запрос.УстановитьПараметр("ТекстВопроса", Вопрос.ТекстФормулировки);
    
    Если НЕ Вопрос.Ссылка.Пустая() Тогда
        Запрос.УстановитьПараметр("ТекущийВопрос", Вопрос.Ссылка);
    КонецЕсли;
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Возврат НЕ Выборка.Следующий(); // True если уникален
    
КонецФункции

// Детальная проверка уникальности узла с диагностикой
Функция ПроверитьУникальностьУзла(Узел) Экспорт
    
    // ДИАГНОСТИКА
    Сообщить("   Проверка уникальности узла: " + Узел.Наименование + 
            " (Ссылка пустая: " + Узел.Ссылка.Пустая() + ")");
    
    Запрос = Новый Запрос;
    
    Если Узел.Ссылка.Пустая() Тогда
        // Для новых объектов - проверяем только по наименованию
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    Узлы.Ссылка,
        |    Узлы.Наименование
        |ИЗ
        |    Справочник.УзлыБинарногоДерева КАК Узлы
        |ГДЕ
        |    Узлы.Наименование = &НаименованиеУзла";
        
        Сообщить("   Режим: проверка нового узла");
    Иначе
        // Для существующих объектов - исключаем текущий узел
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    Узлы.Ссылка,
        |    Узлы.Наименование
        |ИЗ
        |    Справочник.УзлыБинарногоДерева КАК Узлы
        |ГДЕ
        |    Узлы.Наименование ПОДОБНО &НаименованиеУзла
        |    И Узлы.Ссылка <> &ТекущийУзел";
        
        Сообщить("   Режим: проверка существующего узла");
    КонецЕсли;
    
    Запрос.УстановитьПараметр("НаименованиеУзла", Узел.Наименование);
    
    Если НЕ Узел.Ссылка.Пустая() Тогда
        Запрос.УстановитьПараметр("ТекущийУзел", Узел.Ссылка);
    КонецЕсли;
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    НайденДубликат = Выборка.Следующий();
    
    Если НайденДубликат Тогда
        Сообщить("   ❌ Найден дубликат: " + Выборка.Наименование + " (" + Выборка.Ссылка + ")");
        Возврат Ложь;
    Иначе
        Сообщить("   ✓ Узел уникален");
        Возврат Истина;
    КонецЕсли;
    
КонецФункции

Функция ПроверитьУникальностьВопросаПоТексту(ТекстВопроса) Экспорт
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    КОЛИЧЕСТВО(Вопросы.Ссылка) КАК Количество
    |ИЗ
    |    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы
    |ГДЕ
    |    Вопросы.ТекстФормулировки ПОДОБНО &ТекстВопроса";
    
    Запрос.УстановитьПараметр("ТекстВопроса", ТекстВопроса);
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    Выборка.Следующий();
    Возврат Выборка.Количество = 0;
КонецФункции

Функция СоздатьВопрос(ТекстВопроса, Описание = "") Экспорт
	
	// Усиленная проверка уникальности
	//Если Не ПроверитьУникальностьВопросаПоТексту(ТекстВопроса) Тогда
	//    Сообщить("   ОШИБКА: Вопрос с текстом '" + ТекстВопроса + "' уже существует!");
	//    Возврат НайтиВопросПоТексту(ТекстВопроса);  // Возвращаем существующий
	//КонецЕсли;	
	
	
    // ПРОВЕРКА УНИКАЛЬНОСТИ ПЕРЕД СОЗДАНИЕМ
    СуществующийВопрос = НайтиВопросПоТексту(ТекстВопроса);
    Если СуществующийВопрос <> Неопределено Тогда
        Сообщить("   Вопрос уже существует: " + ТекстВопроса);
        Возврат СуществующийВопрос;
    КонецЕсли;
    
    Попытка
        НовыйВопрос = ПланыВидовХарактеристик.ВопросыДляТестирования.СоздатьЭлемент();
        НовыйВопрос.Наименование = ТекстВопроса;
        НовыйВопрос.ТекстФормулировки = ТекстВопроса;
        
        Если НовыйВопрос.Метаданные().Реквизиты.Найти("Описание") <> Неопределено Тогда
            НовыйВопрос.Описание = Описание;
        ИначеЕсли НовыйВопрос.Метаданные().Реквизиты.Найти("Комментарий") <> Неопределено Тогда
            НовыйВопрос.Комментарий = Описание;
        КонецЕсли;
        
        НовыйВопрос.ТипОтвета = Перечисления.ТипыОтветовНаВопрос.Булево;
        НовыйВопрос.ЗаполнятьАвтоматически = Истина;
        
        // ПРОВЕРКА УНИКАЛЬНОСТИ ПЕРЕД ЗАПИСЬЮ
        Если Не ПроверитьУникальностьВопроса(НовыйВопрос) Тогда
            Сообщить("   ОШИБКА: Вопрос с таким текстом уже существует!");
            Возврат Неопределено;
        КонецЕсли;
        
        НовыйВопрос.Записать();
        
        Сообщить("   ✓ Создан вопрос: " + ТекстВопроса);
        
        Возврат НовыйВопрос;
        
    Исключение
        Сообщить("   ОШИБКА при создании вопроса '" + ТекстВопроса + "': " + ОписаниеОшибки());
        ВызватьИсключение "Ошибка при создании вопроса: " + ОписаниеОшибки();
    КонецПопытки;
    
КонецФункции


// Исправленная функция поиска следующего узла
Функция НайтиСледующийУзелИзДокумента(Тест, ТекущийУзел, Ответ) Экспорт
    
    Если ТекущийУзел = Неопределено Тогда
        // Начинаем с корневого узла
        Возврат НайтиКорневойУзел(Тест);
    КонецЕсли;
    
	Сообщить("   Строк в структуре: " + Тест.СтруктураДереваТеста.Количество());
	Если Тест.СтруктураДереваТеста.Количество() = 0 Тогда
	    ВызватьИсключение "ОШИБКА: Структура дерева пустая!";
	КонецЕсли;	
	Сообщить("   Поиск следующего узла для: " + ТекущийУзел.Наименование + ", ответ: " + Ответ);
    
    // Ищем связи для текущего узла в табличной части теста
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
		Сообщить("   Проверка связи: Родитель=" + СтрокаСтруктуры.РодительскийУзел + ", Тип=" + СтрокаСтруктуры.ТипСвязи);
		Если СтрокаСтруктуры.РодительскийУзел = ТекущийУзел 
           И СтрокаСтруктуры.ТипСвязи = Ответ 
           И СтрокаСтруктуры.Активность 
           И СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
            Сообщить("   Найден следующий узел: " + СтрокаСтруктуры.УзелДерева.Наименование);
            Возврат СтрокаСтруктуры.УзелДерева;
        КонецЕсли;
    КонецЦикла;
    
    Сообщить("   ВНИМАНИЕ: Не найден следующий узел для ответа " + Ответ);
    
    // Если не нашли подходящей связи, проверяем является ли текущий узел листом
    Если ТекущийУзел.ЯвляетсяЛистом Тогда
        Сообщить("   Текущий узел является листом - тест завершен");
        Возврат Неопределено;
    КонецЕсли;
    
    // Если не нашли подходящей связи, возвращаем текущий узел (останавливаемся)
    Возврат ТекущийУзел;
    
КонецФункции

// Добавить в область ОсновныеПроцедуры
Функция НайтиСледующийУзелИзРегистра(Тест, ТекущийУзел, Ответ) Экспорт
    
    Если ТекущийУзел = Неопределено Тогда
        // Начинаем с корневого узла из регистра
        Возврат ПолучитьКорневойУзелИзРегистра();
    КонецЕсли;
    
    Сообщить("   Поиск следующего узла из регистра для: " + ТекущийУзел.Наименование + ", ответ: " + Ответ);
    
    // Ищем связь в регистре структуры бинарного дерева
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    СтруктураБинарногоДерева.СледующийУзелДерева
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК СтруктураБинарногоДерева
    |ГДЕ
    |    СтруктураБинарногоДерева.РодительскийУзел = &РодительскийУзел
    |    И СтруктураБинарногоДерева.ТипОтвета = &ТипОтвета
    |    И СтруктураБинарногоДерева.СостояниеСвязи = &СостояниеСвязи";
    
    Запрос.УстановитьПараметр("РодительскийУзел", ТекущийУзел);
    Запрос.УстановитьПараметр("ТипОтвета", Ответ);
    Запрос.УстановитьПараметр("СостояниеСвязи", Перечисления.СостоянияСвязиБинарногоДерева.СвязьАктивна);
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Сообщить("   Найден следующий узел из регистра: " + Выборка.СледующийУзелДерева.Наименование);
        Возврат Выборка.СледующийУзелДерева;
    КонецЕсли;
    
    Сообщить("   ВНИМАНИЕ: Не найден следующий узел в регистре для ответа " + Ответ);
    
    // Если не нашли в регистре, проверяем является ли текущий узел листом
    Если ТекущийУзел.ЯвляетсяЛистом Тогда
        Сообщить("   Текущий узел является листом - тест завершен");
        Возврат Неопределено;
    КонецЕсли;
    
    Возврат Неопределено;
    
КонецФункции

Процедура ЗаписатьОтветПользователя(Тест, УзелДерева, Ответ) Экспорт
    
    // ⭐ ДОБАВИТЬ ПРОВЕРКУ УЗЛА
    Если УзелДерева = Неопределено Тогда
        Сообщить("   ОШИБКА: Попытка записать ответ для неопределенного узла!");
        Возврат;
    КонецЕсли;
    
    // Создаем запись в табличной части ОтветыБинарногоДерева
    НоваяЗапись = Тест.ОтветыБинарногоДерева.Добавить();
    НоваяЗапись.ИдентификаторСтроки = Новый УникальныйИдентификатор;
    НоваяЗапись.УзелДерева = УзелДерева;
    НоваяЗапись.ТипОтветаБинарный = Ответ;
    НоваяЗапись.ВремяОтвета = ТекущаяДата();
    НоваяЗапись.НомерШага = Тест.КоличествоВопросов + 1;
    
    // ⭐ УСИЛЕННАЯ ПРОВЕРКА ВОПРОСА
    Если УзелДерева.Вопрос <> Неопределено Тогда
        НоваяЗапись.Вопрос = УзелДерева.Вопрос;
    Иначе
        Сообщить("   ПРЕДУПРЕЖДЕНИЕ: У узла " + УзелДерева.Наименование + " не установлен вопрос!");
        // Можно создать временный вопрос или пропустить запись
    КонецЕсли;
    
    // Для типа Булево преобразуем в ответ
    Если Ответ = Перечисления.ТипыОтветовБинарногоДерева.Да Тогда
        НоваяЗапись.Ответ = Истина;
    ИначеЕсли Ответ = Перечисления.ТипыОтветовБинарногоДерева.Нет Тогда
        НоваяЗапись.Ответ = Ложь;
    КонецЕсли;
    
    Сообщить("   Записан ответ: " + Ответ + " для узла " + УзелДерева.Наименование);
    Сообщить("   В табличной части теперь " + Тест.ОтветыБинарногоДерева.Количество() + " ответов");
    
КонецПроцедуры


#КонецОбласти

// Получает текущий вопрос для теста
//
// Параметры:
//  Тест - ДокументСсылка.ТестБинарноеДерево
//
// Возвращаемое значение:
//   ПланВидовХарактеристик.ВопросыДляТестирования
//
Функция ПолучитьТекущийВопрос(Тест) Экспорт
	
	Если Тест.ТекущийУзелДерева = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получаем вопрос напрямую из узла дерева
	Возврат Тест.ТекущийУзелДерева.Вопрос;
	
КонецФункции

// Улучшенная функция проверки завершения теста
Функция ТестЗавершен(Тест) Экспорт
    
    Если Тест.ТекущийУзелДерева = Неопределено Тогда
        Сообщить("   Тест завершен: текущий узел не определен");
        Возврат Истина;
    КонецЕсли;
    
    // Диагностика
    Сообщить("   Проверка завершения для узла: " + Тест.ТекущийУзелДерева.Наименование);
    Сообщить("   ЯвляетсяЛистом: " + Тест.ТекущийУзелДерева.ЯвляетсяЛистом);
    
    // Проверяем, является ли текущий узел листом
    Если Тест.ТекущийУзелДерева.ЯвляетсяЛистом Тогда
        Сообщить("   ✅ Узел является листом - тест завершен");
        Возврат Истина;
    КонецЕсли;
    
    // Дополнительная проверка: нет ли дочерних узлов
    Если Не ЕстьДочерниеУзлы(Тест, Тест.ТекущийУзелДерева) Тогда
        Сообщить("   ✅ Нет дочерних узлов - тест завершен");
        Возврат Истина;
    КонецЕсли;
    
    Возврат Ложь;
    
КонецФункции

// Вспомогательная функция проверки дочерних узлов
Функция ЕстьДочерниеУзлы(Тест, Узел) Экспорт
    
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Если СтрокаСтруктуры.РодительскийУзел = Узел 
           И СтрокаСтруктуры.Активность 
           И СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Ложь;
    
КонецФункции

// Создает шаблон бинарного дерева на основе структуры существующего документа-теста.
Процедура СоздатьШаблонИзСуществующегоДерева(ИсточникТест, НаименованиеШаблона) Экспорт
    
    Если ИсточникТест = Неопределено Или ИсточникТест.Ссылка.Пустая() Тогда
        ВызватьИсключение "Не указан тест-источник для создания шаблона";
    КонецЕсли;
    
    // 1. Создаем новый объект шаблона и записываем его, чтобы получить ссылку
    НовыйШаблон = Справочники.ШаблоныБинарныхДеревьев.СоздатьЭлемент();
    НовыйШаблон.Наименование = НаименованиеШаблона;
    НовыйШаблон.ТипТестирования = Перечисления.ТипыТестирования.БинарноеДерево;
    НовыйШаблон.Записать();
    
    // 2. Очищаем старые записи в регистре для этого (нового) шаблона
    Отбор = Новый Структура("ШаблонТеста", НовыйШаблон.Ссылка);
    ОчиститьРегистрСведений("СтруктураБинарногоДерева", Отбор);
    
    // 3. Создаем новый набор записей для регистра
    НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    НаборЗаписей.Отбор.ШаблонТеста.Установить(НовыйШаблон.Ссылка);
    
    // 4. Перебираем табличную часть документа-источника и заполняем набор записей
    Для Каждого СтрокаСтруктуры Из ИсточникТест.СтруктураДереваТеста Цикл
        НоваяЗапись = НаборЗаписей.Добавить();
        НоваяЗапись.ШаблонТеста = НовыйШаблон.Ссылка;
        НоваяЗапись.РодительскийУзел = СтрокаСтруктуры.РодительскийУзел;
        НоваяЗапись.ТипОтвета = СтрокаСтруктуры.ТипСвязи;
        НоваяЗапись.СледующийУзелДерева = СтрокаСтруктуры.УзелДерева;
        НоваяЗапись.СостояниеСвязи = ?(СтрокаСтруктуры.Активность, 
                                    Перечисления.СостоянияСвязиБинарногоДерева.СвязьАктивна, 
                                    Перечисления.СостоянияСвязиБинарногоДерева.ВременноУдаленаИлиВРазработке);
    КонецЦикла;
    
    // 5. Записываем весь набор данных в регистр одной транзакцией
    НаборЗаписей.Записать();
    
    Сообщить("Создан новый шаблон '" + НаименованиеШаблона + "' и его структура сохранена в регистр.");
    
КонецПроцедуры

// Получает аналитику по пройденным тестам
Функция ПолучитьАналитикуПоТестам(ПериодНачало, ПериодКонец) Экспорт
    
    Результат = Новый Структура;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    ОтветыНаВопросыТестов.Тест,
    |    КОЛИЧЕСТВО(ОтветыНаВопросыТестов.Вопрос) КАК КоличествоВопросов,
    |    СУММА(ОтветыНаВопросыТестов.Правильность) КАК СуммаПравильности
    |ИЗ
    |    РегистрСведений.ОтветыНаВопросыТестов КАК ОтветыНаВопросыТестов
    |ГДЕ
    |    ОтветыНаВопросыТестов.Тест.Дата МЕЖДУ &Начало И &Конец
    |СГРУППИРОВАТЬ ПО
    |    ОтветыНаВопросыТестов.Тест";
    
    Запрос.УстановитьПараметр("Начало", ПериодНачало);
    Запрос.УстановитьПараметр("Конец", ПериодКонец);
    
    РезультатЗапроса = Запрос.Выполнить();
    Выборка = РезультатЗапроса.Выбрать();
    
    ВсегоТестов = 0;
    СреднийПроцент = 0;
    
    Пока Выборка.Следующий() Цикл
        ВсегоТестов = ВсегоТестов + 1;
        Если Выборка.КоличествоВопросов > 0 Тогда
            Процент = Выборка.СуммаПравильности / Выборка.КоличествоВопросов * 100;
            СреднийПроцент = СреднийПроцент + Процент;
        КонецЕсли;
    КонецЦикла;
    
    Если ВсегоТестов > 0 Тогда
        СреднийПроцент = Окр(СреднийПроцент / ВсегоТестов, 2);
    КонецЕсли;
    
    Результат.Вставить("ВсегоТестов", ВсегоТестов);
    Результат.Вставить("СреднийПроцент", СреднийПроцент);
    Результат.Вставить("ПериодНачало", ПериодНачало);
    Результат.Вставить("ПериодКонец", ПериодКонец);
    
    Возврат Результат;
    
КонецФункции

// Восстанавливает все активные тесты из регистров
Процедура ВосстановитьАктивныеТесты() Экспорт
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ РАЗЛИЧНЫЕ
    |    СостояниеБинарногоДерева.Тест
    |ИЗ
    |    РегистрСведений.СостояниеБинарногоДерева КАК СостояниеБинарногоДерева
    |ГДЕ
    |    СостояниеБинарногоДерева.ТекущийУзел <> NULL";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Сообщить("Активные тесты для восстановления:");
    
    Пока Выборка.Следующий() Цикл
        Попытка
            Тест = Выборка.Тест.ПолучитьОбъект();
            Если Тест.Завершен = Ложь Тогда
                ВосстановитьСостояниеТестаИзРегистра(Тест);
                Сообщить("   Восстановлен: " + Тест.Ссылка);
            КонецЕсли;
        Исключение
            Сообщить("   Ошибка восстановления теста: " + Выборка.Тест);
        КонецПопытки;
    КонецЦикла;
    
КонецПроцедуры

// Проверяет существование регистра БазаЗнаний
Функция РегистрБазаЗнанийСуществует() Экспорт
    
    Попытка
        // Пытаемся создать набор записей - если регистр существует, не будет ошибки
        НаборЗаписей = РегистрыСведений.БазаЗнаний.СоздатьНаборЗаписей();
        Возврат Истина;
    Исключение
        Возврат Ложь;
    КонецПопытки;
    
КонецФункции

// Безопасное добавление в базу знаний
Процедура БезопасноДобавитьВБазуЗнаний(Тест, Узел, Ответ, Правильность) Экспорт
    
    Если НЕ РегистрБазаЗнанийСуществует() Тогда
        Сообщить("   ⚠️ Регистр БазаЗнаний не существует, пропускаем обновление");
        Возврат;
    КонецЕсли;
    
    ДобавитьВБазуЗнаний(Тест, Узел, Ответ, Правильность);
    
КонецПроцедуры


#КонецОбласти


#Область СлужебныеПроцедурыИФункции

// Сохраняет состояние дерева в регистр
//
// Параметры:
//  Тест - ДокументСсылка.ТестБинарноеДерево
//  ТекущийУзел - УникальныйИдентификатор
//
Процедура СохранитьСостояниеДерева(Тест, ТекущийУзел) Экспорт
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.СостояниеБинарногоДерева.СоздатьНаборЗаписей();
	
	// Чтение данных из регистра сведений
	НаборЗаписей.Отбор.Тест.Установить(Тест.Ссылка);
	НаборЗаписей.Прочитать();
	
	// Удаляем старые записи
	Для каждого ЗаписьРегистра Из НаборЗаписей Цикл
		НаборЗаписей.Удалить(ЗаписьРегистра);
	КонецЦикла;
	
	// Запись данных в регистр сведений
	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Тест = Тест.Ссылка;
	НоваяЗапись.ТекущийУзел = ТекущийУзел;
	
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Получает состояние дерева из регистра
//
// Параметры:
//  Тест - ДокументСсылка.ТестБинарноеДерево
//
// Возвращаемое значение:
//   Структура
//
Функция ПолучитьСостояниеДерева(Тест) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СостояниеБинарногоДерева.ТекущийУзел
	|ИЗ
	|	РегистрСведений.СостояниеБинарногоДерева КАК СостояниеБинарногоДерева
	|ГДЕ
	|	СостояниеБинарногоДерева.Тест = &Тест";
	
	Запрос.УстановитьПараметр("Тест", Тест.Ссылка);
	
	Результат = Запрос.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		Состояние = Новый Структура;
		Состояние.Вставить("ТекущийУзел", Результат.ТекущийУзел);
		Возврат Состояние;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Исправленная универсальная функция очистки регистра сведений
Процедура ОчиститьРегистрСведений(ИмяРегистра, СтруктураОтбора = Неопределено) Экспорт
    
    Попытка
        // Получаем менеджер регистра по имени
        МенеджерРегистра = РегистрыСведений[ИмяРегистра];
        Если МенеджерРегистра = Неопределено Тогда
            Сообщить("Регистр сведений '" + ИмяРегистра + "' не найден");
            Возврат;
        КонецЕсли;
        
        // Создаем набор записей
        НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
        
        // Устанавливаем отбор, если передан
        Если СтруктураОтбора <> Неопределено Тогда
            Для Каждого ЭлементОтбора Из СтруктураОтбора Цикл
                Попытка
                    НаборЗаписей.Отбор[ЭлементОтбора.Ключ].Установить(ЭлементОтбора.Значение);
                Исключение
                    Сообщить("Ошибка установки отбора по полю '" + ЭлементОтбора.Ключ + "': " + ОписаниеОшибки());
                КонецПопытки;
            КонецЦикла;
        КонецЕсли;
        
        // Записываем пустой набор (удаляем записи)
        НаборЗаписей.Записать();
        
        Сообщить("Регистр '" + ИмяРегистра + "' очищен" + 
                 ?(СтруктураОтбора = Неопределено, " полностью", " с отбором"));
                 
    Исключение
        Сообщить("Ошибка очистки регистра '" + ИмяРегистра + "': " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры

// Улучшенная процедура сохранения с трассировкой
Процедура СохранитьСостояниеТестаВРегистр(Тест) Экспорт
    
    Если Тест = Неопределено Или Тест.Ссылка.Пустая() Тогда
        Сообщить("Ошибка: Неверный тест для сохранения");
        Возврат;
    КонецЕсли;
    
    Попытка
        // ⭐ ДЕТАЛЬНАЯ ДИАГНОСТИКА
        Сообщить("=== ВЫЗОВ СОХРАНЕНИЯ В РЕГИСТР ===");
        Сообщить("   Тест: " + Тест.Ссылка);
        Сообщить("   ТекущийУзел: " + ?(Тест.ТекущийУзелДерева = Неопределено, "Неопределено", Тест.ТекущийУзелДерева.Наименование));
        Сообщить("   Пустая ссылка: " + ?(Тест.ТекущийУзелДерева = Неопределено, "Н/Д", Тест.ТекущийУзелДерева.Пустая()));
        
        // ⭐ ВАЖНОЕ ИСПРАВЛЕНИЕ: НИКОГДА не сохраняем пустой узел
        Если Тест.ТекущийУзелДерева = Неопределено ИЛИ Тест.ТекущийУзелДерева.Пустая() Тогда
            Сообщить("   ❌ ОТМЕНА СОХРАНЕНИЯ: Текущий узел пустой!");
            Сообщить("   Стек вызова: " + Сред(ОписаниеОшибки(), 1, 500)); // Диагностика кто вызывает
            Возврат;
        КонецЕсли;
        
        // Создаем набор записей с отбором по тесту
        НаборЗаписей = РегистрыСведений.СостояниеБинарногоДерева.СоздатьНаборЗаписей();
        НаборЗаписей.Отбор.Тест.Установить(Тест.Ссылка);
        
        // Читаем существующие записи
        НаборЗаписей.Прочитать();
        
        // Удаляем старые записи
        Если НаборЗаписей.Количество() > 0 Тогда
            Для Каждого ЗаписьРегистра Из НаборЗаписей Цикл
                НаборЗаписей.Удалить(ЗаписьРегистра);
            КонецЦикла;
        КонецЕсли;
        
        // Создаем хранилище
        ХранилищеДанных = СформироватьДанныеДереваДляХранилища(Тест);
        
        // Добавляем новую запись
        НоваяЗапись = НаборЗаписей.Добавить();
        НоваяЗапись.Тест = Тест.Ссылка;
        НоваяЗапись.ТекущийУзел = Тест.ТекущийУзелДерева;
        НоваяЗапись.ДеревоВопросов = ХранилищеДанных;
        
        НаборЗаписей.Записать();
        
        Сообщить("   ✅ Состояние теста УСПЕШНО сохранено в регистр");
        Сообщить("   Сохранен узел: " + Тест.ТекущийУзелДерева.Наименование);
        
    Исключение
        Сообщить("Ошибка сохранения состояния теста в регистр: " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры

// Улучшенная процедура восстановления состояния теста из регистра
Процедура ВосстановитьСостояниеТестаИзРегистра(Тест) Экспорт
    
    Если Тест = Неопределено Или Тест.Ссылка.Пустая() Тогда
        Сообщить("Ошибка: Неверный тест для восстановления");
        Возврат;
    КонецЕсли;
    
    Попытка
        Запрос = Новый Запрос;
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    СостояниеБинарногоДерева.ТекущийУзел,
        |    СостояниеБинарногоДерева.ДеревоВопросов
        |ИЗ
        |    РегистрСведений.СостояниеБинарногоДерева КАК СостояниеБинарногоДерева
        |ГДЕ
        |    СостояниеБинарногоДерева.Тест = &Тест";
        
        Запрос.УстановитьПараметр("Тест", Тест.Ссылка);
        Результат = Запрос.Выполнить();
        Выборка = Результат.Выбрать();
        
        Если Выборка.Следующий() Тогда
            Сообщить("Найдены данные в регистре для восстановления:");
            Сообщить("   ТекущийУзел: " + ?(Выборка.ТекущийУзел = Неопределено, "Неопределено", Выборка.ТекущийУзел.Наименование));
            
            // ⭐ ВАЖНО: Восстанавливаем простой текущий узел
            Если Выборка.ТекущийУзел <> Неопределено Тогда
                Тест.ТекущийУзелДерева = Выборка.ТекущийУзел;
                Сообщить("   ✓ Восстановлен текущий узел: " + Выборка.ТекущийУзел.Наименование);
                
                // ⭐ ОБЯЗАТЕЛЬНО ЗАПИСЫВАЕМ ТЕСТ!
                Тест.Записать();
                Сообщить("   Тест записан после восстановления состояния");
            Иначе
                Сообщить("   ⚠️ Текущий узел в регистре неопределен - нечего восстанавливать");
                // ⭐ ДОБАВЛЯЕМ: Восстанавливаем корневой узел как запасной вариант
                КорневойУзел = НайтиКорневойУзел(Тест);
                Если КорневойУзел <> Неопределено Тогда
                    Тест.ТекущийУзелДерева = КорневойУзел;
                    Тест.Записать();
                    Сообщить("   ✓ Восстановлен корневой узел как запасной вариант: " + КорневойУзел.Наименование);
                КонецЕсли;
            КонецЕсли;
            
            // ⭐ ДОПОЛНИТЕЛЬНО: Восстанавливаем сложные данные из хранилища
            Если Выборка.ДеревоВопросов <> Неопределено Тогда
                ВосстановитьДеревоВопросовИзХранилища(Тест, Выборка.ДеревоВопросов);
            КонецЕсли;
            
        Иначе
            Сообщить("⚠️ Данные для восстановления не найдены в регистре");
        КонецЕсли;
        
    Исключение
        Сообщить("Ошибка восстановления состояния теста из регистра: " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры

// Диагностическая процедура для проверки ВСЕХ записей в регистре состояния
Процедура ПроверитьВсеЗаписиВРегистреСостояния() Экспорт
    Сообщить("=== ДИАГНОСТИКА ВСЕХ ЗАПИСЕЙ РЕГИСТРА СОСТОЯНИЯ ===");
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Состояние.Тест,
    |    Состояние.ТекущийУзел,
    |    Состояние.ДеревоВопросов
    |ИЗ
    |    РегистрСведений.СостояниеБинарногоДерева КАК Состояние";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    КоличествоЗаписей = 0;
    Пока Выборка.Следующий() Цикл
        КоличествоЗаписей = КоличествоЗаписей + 1;
        Сообщить("Запись " + КоличествоЗаписей + ":");
        Сообщить("   Тест: " + Выборка.Тест);
        Сообщить("   ТекущийУзел: " + ?(Выборка.ТекущийУзел = Неопределено, "Неопределено", Выборка.ТекущийУзел.Наименование));
        Сообщить("   ДеревоВопросов: " + ?(Выборка.ДеревоВопросов = Неопределено, "Неопределено", "Заполнено"));
    КонецЦикла;
    
    Сообщить("Всего записей в регистре: " + КоличествоЗаписей);
КонецПроцедуры

// В модуль ТестированиеБинарноеДерево
Функция ПолучитьТекстовоеПредставлениеСтруктурыДереваИзРегистра(СсылкаНаШаблон) Экспорт
    
    Если СсылкаНаШаблон = Неопределено Тогда
        Возврат "Шаблон не указан";
    КонецЕсли;
    
    // Используем существующую логику из ПроверитьДанныеВРегистре
    Текст = "=== СТРУКТУРА БИНАРНОГО ДЕРЕВА ===|";
    Текст = Текст + "|Шаблон: " + СсылкаНаШаблон.Наименование + "|";
    
    // Получаем данные через существующий запрос
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Узел.Наименование,
    |    Узел.Уровень,
    |    Узел.ЯвляетсяЛистом,
    |    Вопрос.ТекстФормулировки КАК Вопрос
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
    |        ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК Узел
    |        ПО Структура.СледующийУзелДерева = Узел.Ссылка
    |        ЛЕВОЕ СОЕДИНЕНИЕ ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопрос
    |        ПО Узел.Вопрос = Вопрос.Ссылка
    |ГДЕ
    |    Структура.ШаблонТеста = &ШаблонТеста
    |УПОРЯДОЧИТЬ ПО
    |    Узел.Уровень";
    
    Запрос.УстановитьПараметр("ШаблонТеста", СсылкаНаШаблон);
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Пока Выборка.Следующий() Цикл
        Отступ = Лев("  ", Выборка.Уровень * 2);
        ТипУзла = ?(Выборка.ЯвляетсяЛистом, "Лист", "Ветка");
        
        Текст = Текст + "|" + Отступ + ТипУзла + ": " + Выборка.Наименование;
        
        Если Выборка.Вопрос <> Неопределено Тогда
            Текст = Текст + "|" + Отступ + "  Вопрос: " + Выборка.Вопрос;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Текст;
    
КонецФункции

// Пример использования:
Процедура ОчиститьБазуЗнанийПоТесту(Тест) Экспорт
    
    Отбор = Новый Структура;
    Отбор.Вставить("Тест", Тест.Ссылка);
    
    ОчиститьРегистрСведений("БазаЗнаний", Отбор);
    
КонецПроцедуры

// Переименованная функция чтобы избежать конфликта имен
Функция РассчитатьПравильностьОтветаДляРегистра(ОтветСтрока) Экспорт
    
    // Для бинарного дерева правильность определяется достижением листового узла
    Если ОтветСтрока.УзелДерева <> Неопределено 
       И ОтветСтрока.УзелДерева.ЯвляетсяЛистом Тогда
        Возврат Истина; // 100% правильность для достижения конечного узла
    КонецЕсли;
    
    Возврат Ложь;
    
КонецФункции

// Получает вопрос по узлу дерева
Функция ПолучитьВопросПоУзлу(Тест, ТекущийУзел) Экспорт
    
    Если ТекущийУзел = Неопределено Тогда
        Возврат Неопределено;
    КонецЕсли;
    
    // Получаем вопрос напрямую из узла
    Возврат ТекущийУзел.Вопрос;
    
КонецФункции

// Исправленная функция расчета результата для бинарного дерева
Процедура РассчитатьРезультатТеста(Тест) Экспорт
    
    Если Тест.ТипТестирования = Перечисления.ТипыТестирования.БинарноеДерево Тогда
        // Для бинарного дерева тест считается сданным, если достигнут листовой узел
        Если Тест.Завершен И Тест.ТекущийУзелДерева <> Неопределено Тогда
            Тест.РезультатСдачи = Перечисления.РезультатыСдачи.Сдан;
            Тест.ПроцентЗавершения = 100;
        Иначе
            Тест.РезультатСдачи = Перечисления.РезультатыСдачи.НеСдан;
            // Рассчитываем процент по количеству пройденных шагов
            ВсегоОтветов = Тест.ОтветыБинарногоДерева.Количество();
            Если Тест.СтруктураДереваТеста.Количество() > 0 Тогда
                Тест.ПроцентЗавершения = Окр(ВсегоОтветов / Тест.СтруктураДереваТеста.Количество() * 100, 2);
            КонецЕсли;
        КонецЕсли;
    Иначе
        // Старая логика для плоского тестирования
        Если Тест.Завершен Тогда
            КоличествоВопросов = Тест.ВопросыБинарногоДерева.Количество();
            Если КоличествоВопросов > 0 Тогда
                НабоаноБаллов = Тест.ВопросыБинарногоДерева.Итог("Правильность") / КоличествоВопросов;
                Если ЗначениеЗаполнено(Тест.ШаблонТеста) Тогда
                    НеобходимоБаллов = Тест.ШаблонТеста.ПроцентДляСдачи;
                    Если НабоаноБаллов >= НеобходимоБаллов Тогда
                        Тест.РезультатСдачи = Перечисления.РезультатыСдачи.Сдан;
                    Иначе
                        Тест.РезультатСдачи = Перечисления.РезультатыСдачи.НеСдан;
                    КонецЕсли;
                Иначе
                    Тест.РезультатСдачи = Перечисления.РезультатыСдачи.НеСдан;
                КонецЕсли;
            Иначе
                Тест.РезультатСдачи = Перечисления.РезультатыСдачи.НеСдан;
            КонецЕсли;
            Тест.ПроцентЗавершения = 100;
        КонецЕсли;
    КонецЕсли;
    
КонецПроцедуры

#КонецОбласти


#Область ВспомогательныеПроцедуры

// Поместить в общий модуль "ТестированиеБинарноеДерево"

// Поместить в общий модуль "ТестированиеБинарноеДерево"

Функция СформироватьТекстовоеПредставлениеДляЭкспорта(Шаблон) Экспорт
    
    // Получаем всю структуру связей дерева одним запросом
    Запрос = Новый Запрос;
    Запрос.Текст =
    "ВЫБРАТЬ
    |    Структура.РодительскийУзел КАК Родитель,
    |    Структура.РодительскийУзел.Наименование КАК РодительИмя,
    |    Структура.ТипОтвета КАК ТипОтвета,
    |    Структура.СледующийУзелДерева КАК Потомок,
    |    Структура.СледующийУзелДерева.Наименование КАК ПотомокИмя,
    |    Структура.СледующийУзелДерева.ЯвляетсяЛистом КАК ПотомокЭтоЛист,
    |    Структура.СледующийУзелДерева.Вопрос.ТекстФормулировки КАК ПотомокВопрос
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
    |ГДЕ
    |    Структура.ШаблонТеста = &Шаблон"; // <-- УДАЛЕНА СТРОКА С УПОРЯДОЧИВАНИЕМ
    
    Запрос.УстановитьПараметр("Шаблон", Шаблон);
    Выборка = Запрос.Выполнить().Выбрать();
    
    ТекстДляФайла = "Структура дерева для шаблона: " + Шаблон.Наименование + Символы.ПС + Символы.ПС;
    
    Пока Выборка.Следующий() Цикл
        
        Если Выборка.Родитель.Пустая() Тогда
            // Это корневой узел
            ТекстДляФайла = ТекстДляФайла + "[КОРЕНЬ] -> " + Выборка.ПотомокИмя + Символы.ПС;
            Если НЕ Выборка.ПотомокЭтоЛист Тогда
                ТекстДляФайла = ТекстДляФайла + "    Вопрос: " + Выборка.ПотомокВопрос + Символы.ПС;
            КонецЕсли;
        Иначе
            // Это дочерний узел
            ТекстДляФайла = ТекстДляФайла + "    " + Выборка.РодительИмя + " --(" + Выборка.ТипОтвета + ")--> " + Выборка.ПотомокИмя + Символы.ПС;
            Если НЕ Выборка.ПотомокЭтоЛист И ЗначениеЗаполнено(Выборка.ПотомокВопрос) Тогда // Добавлена проверка
                 ТекстДляФайла = ТекстДляФайла + "        Вопрос: " + Выборка.ПотомокВопрос + Символы.ПС;
            КонецЕсли;
        КонецЕсли;
        
    КонецЦикла;
    
    Возврат ТекстДляФайла;
    
КонецФункции

 // Очищает структуру дерева шаблона теста
Процедура ОчиститьСтруктуруДерева(ШаблонТеста) Экспорт
    
    Если ШаблонТеста.Ссылка.Пустая() Тогда
        Возврат;
    КонецЕсли;
    
    // Удаляем все записи структуры дерева
    ШаблонТеста.СтруктураДереваТеста.Очистить();
    
КонецПроцедуры

// Вспомогательные процедуры

// Функция возвращает пустое значение для указанного типа объекта
Функция ЗначениеПоУмолчанию(ТипОбъекта = Неопределено) Экспорт
    
    Если ТипОбъекта = Неопределено Тогда
        Возврат Неопределено;
    КонецЕсли;
    
    Попытка
        // Для справочников
        Если ТипОбъекта = Тип("СправочникСсылка") Тогда
            Возврат Справочники[ТипОбъекта.Имя].ПустаяСсылка();
        КонецЕсли;
        
        // Для документов
        Если ТипОбъекта = Тип("ДокументСсылка") Тогда
            Возврат Документы[ТипОбъекта.Имя].ПустаяСсылка();
        КонецЕсли;
        
        // Для планов видов характеристик
        Если ТипОбъекта = Тип("ПланВидовХарактеристикСсылка") Тогда
            Возврат ПланыВидовХарактеристик[ТипОбъекта.Имя].ПустаяСсылка();
        КонецЕсли;
        
        // Для перечислений
        Если ТипОбъекта = Тип("ПеречислениеСсылка") Тогда
            Возврат Перечисления[ТипОбъекта.Имя].ПустаяСсылка();
        КонецЕсли;
        
    Исключение
        // В случае ошибки возвращаем Неопределено
        ВызватьИсключение "Ошибка проверки значения: " + ОписаниеОшибки();;
    КонецПопытки;
    
    Возврат Неопределено;
    
КонецФункции

Функция НайтиПервогоРеспондента() Экспорт
    // Ищем администратора
    Респондент = Справочники.Пользователи.НайтиПоНаименованию("Администратор");
    Если Не Респондент.Пустая() Тогда
        Возврат Респондент;
    КонецЕсли;
    
    // Или первого пользователя
    Респонденты = Справочники.Пользователи.Выбрать();
    Если Респонденты.Следующий() Тогда
        Возврат Респонденты.Ссылка;
    КонецЕсли;
    
    // Или первого физического лица
    ФизическиеЛица = Справочники.ФизическиеЛица.Выбрать();
    Если ФизическиеЛица.Следующий() Тогда
        Возврат ФизическиеЛица.Ссылка;
    КонецЕсли;
    
    Возврат ЗначениеПоУмолчанию(Метаданные.Справочники.Пользователи);
КонецФункции

Процедура ИнициализироватьСтруктуруДереваДляТеста(Тест) Экспорт
    // Копируем структуру дерева из регистра в табличную часть теста
    НаборЗаписейРегистр = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    НаборЗаписейРегистр.Прочитать();
    
    // Правильное добавление в табличную часть документа
    Пока НаборЗаписейРегистр.Следующий() Цикл
        НоваяЗапись = Тест.СтруктураДереваТеста.Добавить();
        НоваяЗапись.УзелДерева = НаборЗаписейРегистр.СледующийУзелДерева;
		
//// Добавь эти проверки в отладчике:
//Сообщить("Тип УзелДерева: " + ТипЗнч(УзелДерева));
//Сообщить("УзелДерева = Неопределено: " + (УзелДерева = Неопределено));
//Если УзелДерева <> Неопределено Тогда
//    Сообщить("УзелДерева.Ссылка: " + УзелДерева.Ссылка);
//    Сообщить("УзелДерева.Ссылка.Пустая(): " + УзелДерева.Ссылка.Пустая());
//    Сообщить("УзелДерева.Наименование: " + УзелДерева.Наименование);
//КонецЕсли;		
		
        НоваяЗапись.РодительскийУзел = НаборЗаписейРегистр.РодительскийУзел;
        НоваяЗапись.ТипСвязи = НаборЗаписейРегистр.ТипОтвета;
        НоваяЗапись.Вопрос = НаборЗаписейРегистр.Вопрос;
        НоваяЗапись.Уровень = НаборЗаписейРегистр.СледующийУзелДерева.Уровень;
        НоваяЗапись.ЯвляетсяЛистом = НаборЗаписейРегистр.ЯвляетсяЛистом;
        НоваяЗапись.Активность = Истина;
    КонецЦикла;
    
    Тест.Записать();
КонецПроцедуры

Процедура УстановитьКорневойУзелДляТеста(Тест) Экспорт
    // Находим корневой узел (узел без родителя)
    КорневойУзел = Справочники.УзлыБинарногоДерева.НайтиПоНаименованию("Узел_001_Корневой");
    Если Не КорневойУзел.Пустая() Тогда
        Тест.ТекущийУзелДерева = КорневойУзел;
        Тест.КоличествоВопросов = 7;
        Тест.ГлубинаДерева = 4;
        Тест.МаксимальнаяГлубинаДерева = 4;
        Тест.МаксимальноеКоличествоВопросов = 7;
        Тест.Записать();
    КонецЕсли;
КонецПроцедуры

Функция ПолучитьТекущийВопросБинарногоДерева(Тест) Экспорт
    Если Тест.ТекущийУзелДерева.Пустая() Тогда
        Возврат ЗначениеПоУмолчанию(Метаданные.ПланыВидовХарактеристик.ВопросыДляТестирования);
    КонецЕсли;
    
    Возврат Тест.ТекущийУзелДерева.Вопрос;
КонецФункции

Процедура ОбработатьОтветБинарногоДерева(Тест, ТипОтвета) Экспорт
    Если Тест.ТекущийУзелДерева.Пустая() ИЛИ Тест.Завершен Тогда
        Возврат;
    КонецЕсли;
    
    // Записываем ответ в табличную часть
    ЗаписатьОтветВТест(Тест, ТипОтвета);
    
    // Находим следующий узел
    СледующийУзел = НайтиСледующийУзелПоОтвету(Тест.ТекущийУзелДерева, ТипОтвета);
    Если Не СледующийУзел.Пустая() Тогда
        Тест.ТекущийУзелДерева = СледующийУзел;
        
        // Обновляем статистику
        ОбновитьСтатистикуТеста(Тест);
        
        // Если узел является листом - завершаем тест
        Если СледующийУзел.ЯвляетсяЛистом Тогда
            Тест.Завершен = Истина;
            Тест.РезультатСдачи = Перечисления.РезультатыСдачи.Сдан;
            Тест.ВремяЗавершения = ТекущаяДата();
            Тест.ПроцентЗавершения = 100;
        КонецЕсли;
        
        Тест.Записать();
    КонецЕсли;
КонецПроцедуры

Процедура ЗаписатьОтветВТест(Тест, ТипОтвета) Экспорт
    // Правильное добавление в табличную часть ответов
    НоваяЗапись = Тест.ОтветыБинарногоДерева.Добавить();
    
    НоваяЗапись.ИдентификаторСтроки = Новый УникальныйИдентификатор;
    НоваяЗапись.УзелДерева = Тест.ТекущийУзелДерева;
    НоваяЗапись.Вопрос = Тест.ТекущийУзелДерева.Вопрос;
    НоваяЗапись.ТипОтветаБинарный = ТипОтвета;
    НоваяЗапись.ВремяОтвета = ТекущаяДата();
    НоваяЗапись.НомерШага = Тест.ОтветыБинарногоДерева.Количество();
    
    // Для типа Булево преобразуем в ответ
    Если ТипОтвета = Перечисления.ТипыОтветовБинарногоДерева.Да Тогда
        НоваяЗапись.Ответ = Истина;
    ИначеЕсли ТипОтвета = Перечисления.ТипыОтветовБинарногоДерева.Нет Тогда
        НоваяЗапись.Ответ = Ложь;
    КонецЕсли;
КонецПроцедуры

Функция НайтиСледующийУзелПоОтвету(ТекущийУзел, ТипОтвета) Экспорт
    // Ищем в регистре структуры бинарного дерева
    НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    НаборЗаписей.Отбор.РодительскийУзел.Установить(ТекущийУзел);
    НаборЗаписей.Отбор.ТипОтвета.Установить(ТипОтвета);
    НаборЗаписей.Прочитать();
    
	Если НаборЗаписей.Следующий() Тогда
		Если НаборЗаписей.Количество() > 0 Тогда
			Возврат НаборЗаписей[0].СледующийУзелДерева;
		КонецЕсли;
	КонецЕсли;
    
    Возврат ЗначениеПоУмолчанию(Метаданные.Справочники.УзлыБинарногоДерева);
КонецФункции

// Обновляет статистику теста
Процедура ОбновитьСтатистикуТеста(Тест) Экспорт
	
    Тест.КоличествоВопросов = Тест.ОтветыБинарногоДерева.Количество();
    
    Если Тест.ТекущийУзелДерева <> Неопределено Тогда
        Тест.ГлубинаДерева = Тест.ТекущийУзелДерева.Уровень;
    КонецЕсли;
    
    // ⭐ ИСПРАВЛЕННЫЙ РАСЧЕТ ПРОЦЕНТА ЗАВЕРШЕНИЯ
    // Рассчитываем процент на основе глубины дерева, а не количества узлов
    Если Тест.Завершен Тогда
        // Если тест завершен - всегда 100%
        Тест.ПроцентЗавершения = 100;
    Иначе
        // Находим максимальную глубину дерева
        МаксимальнаяГлубина = 0;
        Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
            Если СтрокаСтруктуры.Уровень > МаксимальнаяГлубина Тогда
                МаксимальнаяГлубина = СтрокаСтруктуры.Уровень;
            КонецЕсли;
        КонецЦикла;
        
        Если МаксимальнаяГлубина > 0 Тогда
            // Процент = (текущая глубина / максимальная глубина) * 100
            ТекущаяГлубина = ?(Тест.ТекущийУзелДерева <> Неопределено, Тест.ТекущийУзелДерева.Уровень, 0);
            Тест.ПроцентЗавершения = Окр(ТекущаяГлубина / МаксимальнаяГлубина * 100, 0);
        Иначе
            Тест.ПроцентЗавершения = 0;
        КонецЕсли;
        
        // Ограничиваем 99% для незавершенных тестов
        Если Тест.ПроцентЗавершения >= 100 Тогда
            Тест.ПроцентЗавершения = 99;
        КонецЕсли;
    КонецЕсли;
	
КонецПроцедуры

Функция ТестЗавершенБинарноеДерево(Тест) Экспорт
    Возврат Тест.Завершен ИЛИ Тест.ТекущийУзелДерева.Пустая();
КонецФункции



#КонецОбласти


#Область БинарноеДерево

// Модуль для работы с бинарным деревом 

// Процедура для проверки созданной структуры дерева
Процедура ПроверитьСтруктуруДерева(Тест) Экспорт
    Сообщить("=== ВАЛИДАЦИЯ СТРУКТУРЫ ДЕРЕВА ===");
    Сообщить("Всего узлов: " + Тест.СтруктураДереваТеста.Количество());
    
    // Проверка корневого узла
    КорневойУзел = НайтиКорневойУзел(Тест);
    Если КорневойУзел = Неопределено Тогда
        Сообщить("ОШИБКА: Корневой узел не найден!");
    Иначе
        Сообщить("✓ Корневой узел: " + КорневойУзел.Наименование);
	КонецЕсли;
	
    Сообщить("   Проверяем созданные узлы");
    Узлы = Справочники.УзлыБинарногоДерева.Выбрать();
    Сообщить("Созданные узлы дерева:");
    Пока Узлы.Следующий() Цикл
        Сообщить("  - " + Узлы.Наименование + " (Вопрос: " + Узлы.Вопрос.ТекстФормулировки + ")");
    КонецЦикла;
    
    // Проверяем связи в регистре
    НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    НаборЗаписей.Прочитать();
    Сообщить("Связи в структуре дерева:");
    Пока НаборЗаписей.Следующий() Цикл
        Родитель = ?(НаборЗаписей.РодительскийУзел = Неопределено, "КОРЕНЬ", НаборЗаписей.РодительскийУзел.Наименование);
        Сообщить("  - " + Родитель + " -> " + НаборЗаписей.СледующийУзелДерева.Наименование + " (" + НаборЗаписей.ТипОтвета + ")");
    КонецЦикла;
    
КонецПроцедуры


// В области СлужебныеПроцедурыИФункции нужно добавить:


// Создает структуру дерева "Угадай животное" напрямую в регистре, привязывая ее к шаблону.
Процедура СоздатьСтруктуруДереваУгадайЖивотное(ШаблонТеста) Экспорт
    
    // Очищаем существующие данные для этого шаблона
    ОчиститьРегистрСведений("СтруктураБинарногоДерева", Новый Структура("ШаблонТеста", ШаблонТеста.Ссылка));
    
    // Создаем узлы дерева (этот код не меняется)
    Узел1 = СоздатьУзелДерева("Оно живет в воде?", "Определяет среду обитания животного");
    Узел2 = СоздатьУзелДерева("У него 4 ноги?", "Определяет количество ног у наземного животного");
    Узел3 = СоздатьУзелДерева("Это рыба?", "Финальный вопрос для рыбы", Истина); // Добавим признак листа
    Узел4 = СоздатьУзелДерева("У него есть крылья?", "Определяет наличие крыльев у не четвероногих");
    Узел5 = СоздатьУзелДерева("Оно хищник?", "Определяет тип четвероногого животного");
    Узел6 = СоздатьУзелДерева("Это птица?", "Финальный вопрос для птицы", Истина);
    Узел7 = СоздатьУзелДерева("Это змея?", "Финальный вопрос для змеи", Истина);
    Узел8 = СоздатьУзелДерева("Это лев?", "Финальный вопрос для льва", Истина);
    Узел9 = СоздатьУзелДерева("Это собака?", "Финальный вопрос для собаки", Истина);
    
    // Создаем связи между узлами в регистре с помощью новой процедуры
    // Теперь передаем 4 параметра: Шаблон, Родитель, ТипОтвета, СледующийУзел
    
    // Корневой узел (Узел1) - "Оно живет в воде?"
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Неопределено, Неопределено, Узел1.Ссылка);
    
    // Ветка водных животных (ответ "Да" на корневой вопрос)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел1.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел3.Ссылка);
    
    // Ветка наземных животных (ответ "Нет" на корневой вопрос)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел1.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел2.Ссылка);
    
    // Ветка четвероногих (ответ "Да" на вопрос о ногах)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел2.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел5.Ссылка);
    
    // Ветка не четвероногих (ответ "Нет" на вопрос о ногах)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел2.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел4.Ссылка);
    
    // Финальные узлы для не четвероногих
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел4.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел6.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел4.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел7.Ссылка);
    
    // Финальные узлы для четвероногих
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел5.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел8.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел5.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел9.Ссылка);
    
    Сообщить("Структура дерева 'Угадай животное' создана в регистре для шаблона: " + ШаблонТеста.Наименование);
    
КонецПроцедуры

// Создает узел дерева с вопросом
Функция СоздатьУзелДерева(ТекстВопроса, Описание = "", ЯвляетсяЛистом = Ложь, Уровень = 0) Экспорт
	
    // Сначала ищем, возможно такой вопрос уже есть
    Вопрос = НайтиВопросПоТексту(ТекстВопроса);
    Если Вопрос = Неопределено Тогда
        Попытка
            Вопрос = ПланыВидовХарактеристик.ВопросыДляТестирования.СоздатьЭлемент();
            Вопрос.Наименование = ТекстВопроса;
            Вопрос.ТекстФормулировки = ТекстВопроса;
            Вопрос.Обоснование = Описание; 
            Вопрос.ТипОтвета = Перечисления.ТипыОтветовНаВопрос.Булево;
            Вопрос.ЗаполнятьАвтоматически = Истина;
            Вопрос.Записать();
        Исключение
            Сообщить("   ОШИБКА при создании вопроса '" + ТекстВопроса + "': " + ОписаниеОшибки());
            ВызватьИсключение "Ошибка при создании вопроса: " + ОписаниеОшибки();
        КонецПопытки;
    КонецЕсли;

    // Ищем существующий узел по наименованию
    СуществующийУзел = НайтиУзелПоНаименованию(ТекстВопроса);
    Если СуществующийУзел <> Неопределено Тогда
        Сообщить("   Узел уже существует: " + ТекстВопроса);
        Возврат СуществующийУзел;
    КонецЕсли;
    
    // Создаем новый узел
    Попытка
        НовыйУзел = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        НовыйУзел.Наименование = ТекстВопроса;
        НовыйУзел.Вопрос = Вопрос.Ссылка;
        НовыйУзел.ЯвляетсяЛистом = ЯвляетсяЛистом;
        НовыйУзел.Уровень = Уровень;
        
        НовыйУзел.Записать();
        
        Сообщить("   ✓ Создан узел: " + ТекстВопроса);
        
        // Возвращаем сам ОБЪЕКТ, а не пытаемся получить объект из объекта
        Возврат НовыйУзел; 
        
    Исключение
        Сообщить("   ОШИБКА при создании узла '" + ТекстВопроса + "': " + ОписаниеОшибки());
        Возврат Неопределено;
    КонецПопытки;
    
КонецФункции

// Записывает связь в регистр СтруктураБинарногоДерева
Процедура ЗаписатьСвязьВРегистр(ШаблонТеста, РодительскийУзел, ТипСвязи, СледующийУзелДерева) Экспорт
	
	Сообщить("   Запись в регистр: Шаблон=" + ШаблонТеста.Наименование + 
	         ", Родитель=" + ?(РодительскийУзел = Неопределено, "КОРЕНЬ", РодительскийУзел.Наименование) +
	         ", Тип=" + ТипСвязи + 
	         ", Следующий=" + СледующийУзелДерева.Наименование);
	
	НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
	
	// ⭐ ВАЖНО: Устанавливаем отбор по измерениям
	НаборЗаписей.Отбор.ШаблонТеста.Установить(ШаблонТеста);
	НаборЗаписей.Отбор.РодительскийУзел.Установить(РодительскийУзел);
	НаборЗаписей.Отбор.ТипОтвета.Установить(ТипСвязи);

	// ⭐ ВАЖНО: Читаем существующие записи
	НаборЗаписей.Прочитать();

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.ШаблонТеста = ШаблонТеста;
	НоваяЗапись.РодительскийУзел = РодительскийУзел;
	НоваяЗапись.ТипОтвета = ТипСвязи;
	НоваяЗапись.СледующийУзелДерева = СледующийУзелДерева;
	НоваяЗапись.СостояниеСвязи = Перечисления.СостоянияСвязиБинарногоДерева.СвязьАктивна;
	
	// ⭐ ВАЖНО: Записываем набор
	НаборЗаписей.Записать();
	
	Сообщить("   ✓ Запись добавлена в регистр");
	
КонецПроцедуры

// Очищает регистр структуры дерева
Процедура ОчиститьРегистрСтруктурыДерева() Экспорт
    
    НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    
    // ⭐ ПРАВИЛЬНЫЙ СПОСОБ: Устанавливаем отбор и записываем пустой набор
    // Это удалит ВСЕ записи из регистра
    НаборЗаписей.Записать();
    
    Сообщить("Регистр СтруктураБинарногоДерева полностью очищен");
    
КонецПроцедуры

// Получает корневой узел из регистра
Функция ПолучитьКорневойУзелИзРегистра() Экспорт
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    СтруктураБинарногоДерева.СледующийУзелДерева
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК СтруктураБинарногоДерева
    |ГДЕ
    |    СтруктураБинарногоДерева.РодительскийУзел = NULL";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    Если Выборка.Следующий() Тогда
        Возврат Выборка.СледующийУзелДерева;
    КонецЕсли;
    
    Возврат Неопределено;
    
КонецФункции

// В области ВспомогательныеПроцедуры

// Копирует структуру дерева из одного шаблона в другой
Процедура СкопироватьСтруктуруДерева(Источник, Приемник) Экспорт
    
    Если Источник.Ссылка.Пустая() ИЛИ Приемник.Ссылка.Пустая() Тогда
        Возврат;
    КонецЕсли;
    
    // Копируем табличную часть структуры дерева
    Для Каждого СтрокаИсточника Из Источник.СтруктураДереваТеста Цикл
        НоваяСтрока = Приемник.СтруктураДереваТеста.Добавить();
        НоваяСтрока.УзелДерева = СтрокаИсточника.УзелДерева;
        НоваяСтрока.РодительскийУзел = СтрокаИсточника.РодительскийУзел;
        НоваяСтрока.ТипСвязи = СтрокаИсточника.ТипСвязи;
        НоваяСтрока.Вопрос = СтрокаИсточника.Вопрос;
        НоваяСтрока.Уровень = СтрокаИсточника.Уровень;
        НоваяСтрока.ЯвляетсяЛистом = СтрокаИсточника.ЯвляетсяЛистом;
        НоваяСтрока.Активность = СтрокаИсточника.Активность;
    КонецЦикла;
    
КонецПроцедуры

// Вспомогательная процедура для создания тестовой структуры дерева
Процедура СоздатьТестовуюСтруктуруДерева(ВопросыМассив) Экспорт
    
    Если ВопросыМассив.Количество() < 3 Тогда
        Сообщить("   Недостаточно вопросов для создания структуры");
        Возврат;
    КонецЕсли;
    
    Попытка
        Сообщить("   Создание корневого узла...");
        
        // Корневой узел (уровень 0)
        КорневойУзел = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        КорневойУзел.Наименование = "Корневой узел - среда обитания";
        КорневойУзел.Вопрос = ВопросыМассив[0]; // "Оно живет в воде?"
        КорневойУзел.Уровень = 0;
        КорневойУзел.ЯвляетсяЛистом = Ложь;
        КорневойУзел.Записать();
        Сообщить("   ✓ Создан корневой узел: " + КорневойУзел.Наименование);
        
        // Узел уровня 1 (ответ "Да")
        УзелДа = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        УзелДа.Наименование = "Узел водных животных";
        УзелДа.Вопрос = ВопросыМассив[1]; // "Оно большое?"
        УзелДа.Уровень = 1;
        УзелДа.ЯвляетсяЛистом = Ложь;
        УзелДа.Записать();
        Сообщить("   ✓ Создан узел Да: " + УзелДа.Наименование);
        
        // Узел уровня 1 (ответ "Нет")  
        УзелНет = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        УзелНет.Наименование = "Узел наземных животных";
        УзелНет.Вопрос = ВопросыМассив[2]; // "У него 4 ноги?"
        УзелНет.Уровень = 1;
        УзелНет.ЯвляетсяЛистом = Ложь;
        УзелНет.Записать();
        Сообщить("   ✓ Создан узел Нет: " + УзелНет.Наименование);
        
        // Листовые узлы (уровень 2)
        Если ВопросыМассив.Количество() >= 5 Тогда
            // Лист для ответа "Да" -> "Да"
            ЛистДаДа = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
            ЛистДаДа.Наименование = "Лист - кит";
            ЛистДаДа.Вопрос = ВопросыМассив[3]; // "Это кит?"
            ЛистДаДа.Уровень = 2;
            ЛистДаДа.ЯвляетсяЛистом = Истина;
            ЛистДаДа.Записать();
            Сообщить("   ✓ Создан лист ДаДа: " + ЛистДаДа.Наименование);
            
            // Лист для ответа "Нет" -> "Нет"
            ЛистНетНет = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
            ЛистНетНет.Наименование = "Лист - змея";
            ЛистНетНет.Вопрос = ВопросыМассив[4]; // "Это змея?"
            ЛистНетНет.Уровень = 2;
            ЛистНетНет.ЯвляетсяЛистом = Истина;
            ЛистНетНет.Записать();
            Сообщить("   ✓ Создан лист НетНет: " + ЛистНетНет.Наименование);
        КонецЕсли;
        
        Сообщить("   ✓ Тестовая структура дерева создана успешно");
        
    Исключение
        Сообщить("   ОШИБКА при создании структуры: " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры



Функция ПроверитьЦелостностьДанных() Экспорт
    
    Сообщить("=== ПРОВЕРКА ЦЕЛОСТНОСТИ ДАННЫХ БИНАРНОГО ДЕРЕВА ===");
    
    // Проверка дубликатов вопросов - ИСПРАВЛЕННЫЙ ЗАПРОС
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Вопросы.Ссылка,
    |    Вопросы.Наименование,
    |    Вопросы.ТекстФормулировки
    |ИЗ
    |    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    // Ручная группировка в памяти
    ВопросыПоТексту = Новый Соответствие;
    ДубликатыВопросов = 0;
    
    Пока Выборка.Следующий() Цикл
        ТекстВопроса = Выборка.ТекстФормулировки;
        Если ВопросыПоТексту.Получить(ТекстВопроса) = Неопределено Тогда
            ВопросыПоТексту.Вставить(ТекстВопроса, Новый Массив);
        КонецЕсли;
        
        МассивВопросов = ВопросыПоТексту.Получить(ТекстВопроса);
        МассивВопросов.Добавить(Выборка.Ссылка);
    КонецЦикла;
    
    // Поиск дубликатов
    Для Каждого Пара Из ВопросыПоТексту Цикл
        Если Пара.Значение.Количество() > 1 Тогда
            Сообщить("   ДУБЛИКАТ вопроса: " + Пара.Ключ + 
                    " (" + Пара.Значение.Количество() + " копий)");
            ДубликатыВопросов = ДубликатыВопросов + 1;
        КонецЕсли;
    КонецЦикла;
    
    // Проверка дубликатов узлов - ИСПРАВЛЕННЫЙ ЗАПРОС
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Узлы.Ссылка,
    |    Узлы.Наименование
    |ИЗ
    |    Справочник.УзлыБинарногоДерева КАК Узлы";
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    // Ручная группировка в памяти
    УзлыПоНаименованию = Новый Соответствие;
    ДубликатыУзлов = 0;
    
    Пока Выборка.Следующий() Цикл
        НаименованиеУзла = Выборка.Наименование;
        Если УзлыПоНаименованию.Получить(НаименованиеУзла) = Неопределено Тогда
            УзлыПоНаименованию.Вставить(НаименованиеУзла, Новый Массив);
        КонецЕсли;
        
        МассивУзлов = УзлыПоНаименованию.Получить(НаименованиеУзла);
        МассивУзлов.Добавить(Выборка.Ссылка);
    КонецЦикла;
    
    // Поиск дубликатов
    Для Каждого Пара Из УзлыПоНаименованию Цикл
        Если Пара.Значение.Количество() > 1 Тогда
            Сообщить("   ДУБЛИКАТ узла: " + Пара.Ключ + 
                    " (" + Пара.Значение.Количество() + " копий)");
            ДубликатыУзлов = ДубликатыУзлов + 1;
        КонецЕсли;
    КонецЦикла;
    
    Сообщить("=== РЕЗУЛЬТАТЫ ПРОВЕРКИ ===");
    Сообщить("   Дубликатов вопросов: " + ДубликатыВопросов);
    Сообщить("   Дубликатов узлов: " + ДубликатыУзлов);
    
    Возврат ДубликатыВопросов = 0 И ДубликатыУзлов = 0;
    
КонецФункции

Процедура ПроверитьЦелостностьВСистеме() Экспорт
    Результат = ТестированиеБинарноеДерево.ПроверитьЦелостностьДанных();
    Если Результат Тогда
        Сообщить("Целостность данных в порядке!");
    Иначе
        Сообщить("Обнаружены проблемы с целостностью данных!");
    КонецЕсли;
КонецПроцедуры

Функция ПолучитьПрогрессТеста(Тест) Экспорт
    
    Если Тест.Завершен Тогда
        Возврат 100; // Тест завершен
    КонецЕсли;
    
    Если Тест.ТекущийУзелДерева = Неопределено Тогда
        Возврат 0; // Тест еще не начат
    КонецЕсли;
    
    // ⭐ НОВАЯ ЛОГИКА: Расчет прогресса на основе глубины пройденного пути
    Попытка
        // Получаем общее количество уровней в дереве
        МаксУровень = 0;
        Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
            Если СтрокаСтруктуры.Уровень > МаксУровень Тогда
                МаксУровень = СтрокаСтруктуры.Уровень;
            КонецЕсли;
        КонецЦикла;
        
        Если МаксУровень = 0 Тогда
            Возврат 0; // Нет структуры дерева
        КонецЕсли;
        
        // Прогресс = (текущий уровень / максимальный уровень) * 100
        ТекущийУровень = Тест.ТекущийУзелДерева.Уровень;
        Прогресс = Цел(ТекущийУровень / МаксУровень * 100);
        
        // Ограничиваем прогресс 99% для незавершенных тестов
        Если Прогресс >= 100 Тогда
            Прогресс = 99;
        КонецЕсли;
        
        Сообщить("Расчет прогресса: уровень " + ТекущийУровень + "/" + МаксУровень + " = " + Прогресс + "%");
        Возврат Прогресс;
        
    Исключение
        Сообщить("Ошибка расчета прогресса: " + ОписаниеОшибки());
        Возврат 0;
    КонецПопытки;
    
КонецФункции

// Добавить в общий модуль ТестированиеБинарноеДерево
Функция СоздатьЛистовойУзел(Наименование, Вопрос = Неопределено) Экспорт
    
    Если НЕ ЗначениеЗаполнено(Наименование) Тогда
        Возврат Неопределено;
    КонецЕсли;
    
    Попытка
        ЛистовойУзел = Справочники.УзлыБинарногоДерева.СоздатьЭлемент();
        ЛистовойУзел.Наименование = Наименование;
        ЛистовойУзел.Вопрос = Вопрос;
        ЛистовойУзел.ЯвляетсяЛистом = Истина;
        
        // Определяем уровень узла
        Если Вопрос <> Неопределено Тогда
            ЛистовойУзел.Уровень = 1;
        Иначе
            ЛистовойУзел.Уровень = 0;
        КонецЕсли;
        
        // Проверяем уникальность
        Если Не ПроверитьУникальностьУзла(ЛистовойУзел) Тогда
            СуществующийУзел = НайтиУзелПоНаименованию(Наименование);
            Если СуществующийУзел <> Неопределено Тогда
                Возврат СуществующийУзел;
            КонецЕсли;
        КонецЕсли;
        
        ЛистовойУзел.Записать();
        Сообщить("Создан листовой узел: " + Наименование);
        
        Возврат ЛистовойУзел;
        
    Исключение
        Сообщить("Ошибка при создании листового узла: " + ОписаниеОшибки());
        Возврат Неопределено;
    КонецПопытки;
    
КонецФункции

// Добавить в общий модуль ТестированиеБинарноеДерево
Функция ПолучитьТипСвязи(Тест, РодительскийУзел) Экспорт
    
    Если РодительскийУзел = Неопределено Тогда
        Возврат Неопределено;
    КонецЕсли;
    
    Попытка
        Запрос = Новый Запрос;
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    СтруктураДереваТеста.ТипСвязи
        |ИЗ
        |    Документ.Тест.СтруктураДереваТеста КАК СтруктураДереваТеста
        |ГДЕ
        |    СтруктураДереваТеста.Ссылка = &Ссылка
        |    И СтруктураДереваТеста.РодительскийУзел = &РодительскийУзел";
        
        Запрос.УстановитьПараметр("Ссылка", Тест.Ссылка);
        Запрос.УстановитьПараметр("РодительскийУзел", РодительскийУзел);
        
        Результат = Запрос.Выполнить();
        Выборка = Результат.Выбрать();
        
        Если Выборка.Следующий() Тогда
            Возврат Выборка.ТипСвязи;
        КонецЕсли;
    Исключение
        // Если возникла ошибка - возвращаем неопределено
    КонецПопытки;
    
    Возврат Неопределено;
    
КонецФункции

// Добавить в общий модуль ТестированиеБинарноеДерево
Функция ЯвляетсяЛистом(Тест, Узел) Экспорт
    
    Если Узел = Неопределено Тогда
        Возврат Истина;
    КонецЕсли;
    
    // Если у узла есть свойство "ЯвляетсяЛистом" - используем его
    Попытка
        Если Узел.ЯвляетсяЛистом = Истина Тогда
            Возврат Истина;
        КонецЕсли;
    Исключение
        // Свойство не существует - продолжаем проверку
    КонецПопытки;
    
    // Проверяем наличие дочерних узлов в структуре дерева
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    COUNT(*) КАК КоличествоДочерних
    |ИЗ
    |    Документ.Тест.СтруктураДереваТеста КАК СтруктураДереваТеста
    |ГДЕ
    |    СтруктураДереваТеста.Ссылка = &Ссылка
    |    И СтруктураДереваТеста.РодительскийУзел = &Узел";
    
    Запрос.УстановитьПараметр("Ссылка", Тест.Ссылка);
    Запрос.УстановитьПараметр("Узел", Узел.Ссылка);
    
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Возврат Выборка.КоличествоДочерних = 0;
    КонецЕсли;
    
    Возврат Истина;
    
КонецФункции

// Проверка целостности структуры дерева
Функция ПроверитьЦелостностьСтруктурыДерева(Тест) Экспорт
    
    Если Тест.СтруктураДереваТеста.Количество() = 0 Тогда
        Сообщить("ОШИБКА: Структура дерева пустая!");
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем наличие корневого узла
    КорневойУзел = НайтиКорневойУзел(Тест);
    Если КорневойУзел = Неопределено Тогда
        Сообщить("ОШИБКА: Не найден корневой узел!");
        Возврат Ложь;
    КонецЕсли;
    
    // Проверяем уникальность узлов в структуре
    УзлыВСтруктуре = Новый Соответствие;
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
            Ключ = СтрокаСтруктуры.УзелДерева.УникальныйИдентификатор();
            Если УзлыВСтруктуре.Получить(Ключ) <> Неопределено Тогда
                Сообщить("ОШИБКА: Найден дубликат узла в структуре: " + СтрокаСтруктуры.УзелДерева.Наименование);
                Возврат Ложь;
            КонецЕсли;
            УзлыВСтруктуре.Вставить(Ключ, Истина);
        КонецЕсли;
    КонецЦикла;
    
    Сообщить("Целостность структуры дерева проверена успешно");
    Возврат Истина;
    
КонецФункции

// Создание универсального бинарного дерева из вопросов
Процедура СоздатьУниверсальноеБинарноеДерево(Тест, Вопросы) Экспорт
    
    Если Вопросы.Количество() = 0 Тогда
        Сообщить("ОШИБКА: Нет вопросов для создания дерева");
        Возврат;
    КонецЕсли;
    
    // Очищаем существующую структуру
    Тест.СтруктураДереваТеста.Очистить();
    
    // Создаем корневой узел из первого вопроса
    КорневойВопрос = Вопросы[0];
    КорневойУзел = СоздатьУзел("Корневой узел", КорневойВопрос);
    ЗаписатьУзелДереваВТест(Тест, Неопределено, Неопределено, КорневойУзел, КорневойВопрос, Ложь);
    
    // Создаем бинарное дерево из оставшихся вопросов
    СоздатьРекурсивноДерево(Тест, КорневойУзел, Вопросы, 1);
    
    Тест.Записать();
    Сообщить("Универсальное бинарное дерево создано из " + Вопросы.Количество() + " вопросов");
    
КонецПроцедуры

// Рекурсивное создание дерева
Процедура СоздатьРекурсивноДерево(Тест, РодительскийУзел, Вопросы, Индекс) Экспорт
    
    Если Индекс >= Вопросы.Количество() Тогда
        Возврат;
    КонецЕсли;
    
    ТекущийВопрос = Вопросы[Индекс];
    
    // Создаем узел для текущего вопроса
    ТекущийУзел = СоздатьУзел("Узел для: " + ТекущийВопрос.ТекстФормулировки, ТекущийВопрос);
    
    // Определяем, является ли узел листом
    ЯвляетсяЛистом = (Индекс = Вопросы.Количество() - 1);
    
    // Создаем связь "Да"
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Да, 
                            ТекущийУзел, ТекущийВопрос, ЯвляетсяЛистом);
    
    // Рекурсивно создаем следующую ветку
    СоздатьРекурсивноДерево(Тест, ТекущийУзел, Вопросы, Индекс + 1);
    
КонецПроцедуры

// Создание полной бинарной ветки с листовыми узлами
Процедура СоздатьПолнуюБинарнуюВетку(Тест, РодительскийУзел, Вопрос, ТекстДа, ТекстНет) Экспорт
    
    Если РодительскийУзел = Неопределено Или Вопрос = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    // Создаем листовой узел для ответа "Да"
    ЛистДа = СоздатьЛистовойУзел(ТекстДа, Вопрос);
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Да, 
                            ЛистДа, Вопрос, Истина);
    
    // Создаем листовой узел для ответа "Нет"  
    ЛистНет = СоздатьЛистовойУзел(ТекстНет, Вопрос);
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Нет, 
                            ЛистНет, Вопрос, Истина);
    
    Сообщить("Создана полная бинарная ветка для вопроса: " + Вопрос.ТекстФормулировки);
    
КонецПроцедуры

// Вспомогательная функция для поиска раздела
Функция НайтиЛюбойРаздел() Экспорт
    Запрос = Новый Запрос;
    Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1 Ссылка ИЗ Справочник.Разделы";
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    Если Выборка.Следующий() Тогда
        Возврат Выборка.Ссылка;
    КонецЕсли;
    Возврат Неопределено;
КонецФункции

// Находит узел по идентификатору
Функция НайтиУзелПоИдентификатору(Идентификатор) Экспорт
    
    Если Идентификатор = "00000000-0000-0000-0000-000000000000" Тогда
        Возврат Неопределено; // Игнорируем пустой GUID
    КонецЕсли;
    
    Попытка
        УникальныйИД = Новый УникальныйИдентификатор(Идентификатор);
        
        Запрос = Новый Запрос;
        Запрос.Текст = 
        "ВЫБРАТЬ ПЕРВЫЕ 1
        |    Узлы.Ссылка
        |ИЗ
        |    Справочник.УзлыБинарногоДерева КАК Узлы
        |ГДЕ
        |    Узлы.Ссылка = &Идентификатор";
        
        Запрос.УстановитьПараметр("Идентификатор", УникальныйИД);
        
        Результат = Запрос.Выполнить();
        Выборка = Результат.Выбрать();
        
        Если Выборка.Следующий() Тогда
            Возврат Выборка.Ссылка.ПолучитьОбъект();
        КонецЕсли;
        
    Исключение
        // Если не удалось преобразовать идентификатор
    КонецПопытки;
    
    Возврат Неопределено;
    
КонецФункции

// В ПолучитьРазделДляУзла - возвращаем пустую ссылку вместо NULL
Функция ПолучитьРазделДляУзла(УзелДерева) Экспорт
    
    Если УзелДерева = Неопределено Тогда
        Возврат ПредопределенноеЗначение("Справочник.Разделы.ПустаяСсылка");
    КонецЕсли;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ 1
    |    ВопросыБинарногоДерева.Раздел
    |ИЗ
    |    Документ.ТестБинарноеДерево.ВопросыБинарногоДерева КАК ВопросыБинарногоДерева
    |ГДЕ
    |    ВопросыБинарногоДерева.Вопрос = &Вопрос";
    
    Запрос.УстановитьПараметр("Вопрос", УзелДерева.Вопрос);
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Возврат Выборка.Раздел;
    КонецЕсли;
    
    Возврат ПредопределенноеЗначение("Справочник.Разделы.ПустаяСсылка");
    
КонецФункции

// Рассчитывает правильность ответа
Функция РассчитатьПравильностьОтвета(ОтветСтрока) Экспорт
    
    // Для бинарного дерева правильность определяется достижением листового узла
    Если ОтветСтрока.УзелДерева <> Неопределено 
       И ОтветСтрока.УзелДерева.ЯвляетсяЛистом Тогда
        Возврат 1; // 100% правильность для достижения конечного узла
    КонецЕсли;
    
    Возврат 0;
    
КонецФункции


#КонецОбласти


#Область СозданиеДереваУгадайЖивотное

// Создает структуру дерева "Угадай животное" НАПРЯМУЮ В РЕГИСТРЕ, привязывая ее к шаблону.
// Эта процедура нужна для тестов, чтобы подготовить эталонный шаблон.
// ПАРАМЕТР: ШаблонТеста - СправочникОбъект.ШаблоныБинарныхДеревьев
// Создает структуру дерева "Угадай животное" НАПРЯМУЮ В РЕГИСТРЕ для указанного шаблона.
// Создает полную и корректную структуру дерева "Угадай животное" в регистре.
Процедура СоздатьДеревоУгадайЖивотное(ШаблонТеста) Экспорт
    
    Отбор = Новый Структура("ШаблонТеста", ШаблонТеста.Ссылка);
    ОчиститьРегистрСведений("СтруктураБинарногоДерева", Отбор);
    
    // Создаем все необходимые узлы с правильными признаками и уровнями
    Узел_Корень_Среда   = СоздатьУзелДерева("Оно живет в воде?", "Среда обитания", Ложь, 0);
    Узел_Вода_Размер    = СоздатьУзелДерева("Оно большое?", "Размер водного", Ложь, 1);
    Узел_Суша_Ноги      = СоздатьУзелДерева("У него 4 ноги?", "Количество ног", Ложь, 1);
    Узел_Вода_Большое   = СоздатьУзелДерева("У него есть плавники?", "Тип большого водного", Ложь, 2);
    Узел_Вода_Маленькое = СоздатьУзелДерева("У него есть чешуя?", "Тип маленького водного", Ложь, 2);
    Узел_Суша_4ноги     = СоздатьУзелДерева("Оно хищник?", "Тип питания четвероногого", Ложь, 2);
    Узел_Суша_Не4ноги   = СоздатьУзелДерева("У него есть крылья?", "Наличие крыльев", Ложь, 2);
    
    // Листовые узлы
    Лист_Кит      = СоздатьУзелДерева("Это кит?", "Финал", Истина, 3);
    Лист_Акула    = СоздатьУзелДерева("Это акула?", "Финал", Истина, 3);
    Лист_Рыба     = СоздатьУзелДерева("Это рыба?", "Финал", Истина, 3);
    Лист_Осьминог = СоздатьУзелДерева("Это осьминог?", "Финал", Истина, 3);
    Лист_Лев      = СоздатьУзелДерева("Это лев?", "Финал", Истина, 3);
    Лист_Собака   = СоздатьУзелДерева("Это собака?", "Финал", Истина, 3);
    Лист_Птица    = СоздатьУзелДерева("Это птица?", "Финал", Истина, 3);
    Лист_Змея     = СоздатьУзелДерева("Это змея?", "Финал", Истина, 3);

    // Записываем правильные связи в регистр
    
    // Уровень 0 -> 1
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Справочники.УзлыБинарногоДерева.ПустаяСсылка(), Неопределено, Узел_Корень_Среда.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Корень_Среда.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Узел_Вода_Размер.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Корень_Среда.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел_Суша_Ноги.Ссылка);
    
    // Уровень 1 -> 2 (Водные)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Размер.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Узел_Вода_Большое.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Размер.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел_Вода_Маленькое.Ссылка);
    
    // Уровень 1 -> 2 (Наземные)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_Ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Узел_Суша_4ноги.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_Ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел_Суша_Не4ноги.Ссылка);
    
    // Уровень 2 -> 3 (Листья)
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Большое.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Лист_Кит.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Большое.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Лист_Акула.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Маленькое.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Лист_Рыба.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Вода_Маленькое.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Лист_Осьминог.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_4ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Лист_Лев.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_4ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Лист_Собака.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_Не4ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да,  Лист_Птица.Ссылка);
    ЗаписатьСвязьВРегистр(ШаблонТеста.Ссылка, Узел_Суша_Не4ноги.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Лист_Змея.Ссылка);
    
    Сообщить("Полная структура дерева 'Угадай животное' создана в регистре для шаблона: " + ШаблонТеста.Наименование);
    
КонецПроцедуры

// Создает структуру дерева "Угадай животное" НАПРЯМУЮ В ДОКУМЕНТЕ.
// Эта процедура может быть полезна для быстрых тестов, не использующих шаблоны.
// ПАРАМЕТР: Тест - ДокументОбъект.ТестБинарноеДерево
Процедура СоздатьДеревоУгадайЖивотноеНапрямуюВДокументе(Тест) Экспорт
    
    Тест.СтруктураДереваТеста.Очистить();
    
    // Создаем узлы-справочники
    Узел1 = СоздатьУзелДерева("Оно живет в воде?", "Определяет среду обитания животного");
    Узел2 = СоздатьУзелДерева("У него 4 ноги?", "Определяет количество ног у наземного животного");
    Узел3 = СоздатьУзелДерева("Это рыба?", "Финальный вопрос для рыбы", Истина);
    Узел4 = СоздатьУзелДерева("У него есть крылья?", "Определяет наличие крыльев у не четвероногих");
    Узел5 = СоздатьУзелДерева("Оно хищник?", "Определяет тип четвероногого животного");
    Узел6 = СоздатьУзелДерева("Это птица?", "Финальный вопрос для птицы", Истина);
    Узел7 = СоздатьУзелДерева("Это змея?", "Финальный вопрос для змеи", Истина);
    Узел8 = СоздатьУзелДерева("Это лев?", "Финальный вопрос для льва", Истина);
    Узел9 = СоздатьУзелДерева("Это собака?", "Финальный вопрос для собаки", Истина);
    
    // Записываем узлы и связи напрямую в ТАБЛИЧНУЮ ЧАСТЬ ДОКУМЕНТА
    
    // Корневой узел
    ЗаписатьУзелДереваВТест(Тест, Неопределено, Неопределено, Узел1, Узел1.Вопрос, Ложь);
    
    // Ветка водных животных
    ЗаписатьУзелДереваВТест(Тест, Узел1.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел3, Узел3.Вопрос, Истина);
    
    // Ветка наземных животных
    ЗаписатьУзелДереваВТест(Тест, Узел1.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел2, Узел2.Вопрос, Ложь);
    
    // Ветка четвероногих
    ЗаписатьУзелДереваВТест(Тест, Узел2.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел5, Узел5.Вопрос, Ложь);
    
    // Ветка не четвероногих
    ЗаписатьУзелДереваВТест(Тест, Узел2.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел4, Узел4.Вопрос, Ложь);
    
    // Финальные узлы для не четвероногих
    ЗаписатьУзелДереваВТест(Тест, Узел4.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел6, Узел6.Вопрос, Истина);
    ЗаписатьУзелДереваВТест(Тест, Узел4.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел7, Узел7.Вопрос, Истина);
    
    // Финальные узлы для четвероногих
    ЗаписатьУзелДереваВТест(Тест, Узел5.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Да, Узел8, Узел8.Вопрос, Истина);
    ЗаписатьУзелДереваВТест(Тест, Узел5.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, Узел9, Узел9.Вопрос, Истина);

    Сообщить("Структура дерева 'Угадай животное' создана напрямую в документе.");
    
КонецПроцедуры

// Создает ветку водных животных
Процедура СоздатьВеткуВодныхЖивотных(Тест, РодительскийУзел) Экспорт
    
    // Уровень 1: Вопрос о размере для водных животных
    ВопросРазмер = СоздатьВопрос("Оно большое?", "Определяет размер водного животного");
    УзелРазмер = СоздатьУзел("Узел - размер водного животного", ВопросРазмер);
    
    // Связь: Да -> переход к вопросу о размере
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелРазмер, ВопросРазмер, Ложь);
    
    // Ветка для больших водных животных (ответ "Да" на вопрос о размере)
    СоздатьВеткуБольшихВодных(Тест, УзелРазмер);
    
    // Ветка для маленьких водных животных (ответ "Нет" на вопрос о размере)
    СоздатьВеткуМаленькихВодных(Тест, УзелРазмер);
    
КонецПроцедуры

// Создает ветку больших водных животных
Процедура СоздатьВеткуБольшихВодных(Тест, РодительскийУзел) Экспорт
    
    // Уровень 2: Вопрос о наличии плавников для больших водных
    ВопросПлавники = СоздатьВопрос("У него есть плавники?", "Определяет тип большого водного животного");
    УзелПлавники = СоздатьУзел("Узел - плавники у большого животного", ВопросПлавники);
    
    // Связь: Да -> переход к вопросу о плавниках
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелПлавники, ВопросПлавники, Ложь);
    
    // КИТ (Да -> Есть плавники -> Кит)
    ВопросКит = СоздатьВопрос("Это кит?", "Финальный вопрос для кита");
    УзелКит = СоздатьУзел("Узел - кит", ВопросКит);
    ЗаписатьУзелДереваВТест(Тест, УзелПлавники, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелКит, ВопросКит, Истина);
    
    // АКУЛА (Нет -> Нет плавников -> Акула)
    ВопросАкула = СоздатьВопрос("Это акула?", "Финальный вопрос для акулы");
    УзелАкула = СоздатьУзел("Узел - акула", ВопросАкула);
    ЗаписатьУзелДереваВТест(Тест, УзелПлавники, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелАкула, ВопросАкула, Истина);
    
КонецПроцедуры

// Новая процедура для пометки листовых узлов
Процедура ПометитьЛистовыеУзлыЖивотные(Тест) Экспорт
    
    // Список листовых узлов (финальные животные)
    ЛистовыеУзлы = Новый Массив;
    ЛистовыеУзлы.Добавить("Узел - кит");
    ЛистовыеУзлы.Добавить("Узел - акула");
    ЛистовыеУзлы.Добавить("Узел - рыба");
    ЛистовыеУзлы.Добавить("Узел - осьминог");
    ЛистовыеУзлы.Добавить("Узел - лев");
    ЛистовыеУзлы.Добавить("Узел - собака");
    ЛистовыеУзлы.Добавить("Узел - птица");
    ЛистовыеУзлы.Добавить("Узел - змея");
    
    // Обновляем узлы в справочнике
    Для Каждого НаименованиеЛиста Из ЛистовыеУзлы Цикл
        Узел = НайтиУзелПоНаименованию(НаименованиеЛиста);
        Если Узел <> Неопределено Тогда
            Узел.ЯвляетсяЛистом = Истина;
            Узел.Записать();
            Сообщить("   Помечен как листовой: " + НаименованиеЛиста);
        КонецЕсли;
    КонецЦикла;
    
    // Обновляем табличную часть теста
    Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
        Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
            Для Каждого НаименованиеЛиста Из ЛистовыеУзлы Цикл
                Если СтрокаСтруктуры.УзелДерева.Наименование = НаименованиеЛиста Тогда
                    СтрокаСтруктуры.ЯвляетсяЛистом = Истина;
                    Сообщить("   Обновлена строка структуры: " + НаименованиеЛиста);
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
    
КонецПроцедуры

// Создает ветку наземных животных
Процедура СоздатьВеткуНаземныхЖивотных(Тест, РодительскийУзел) Экспорт
    
    // Уровень 1: Вопрос о количестве ног для наземных животных
    ВопросНоги = СоздатьВопрос("У него 4 ноги?", "Определяет количество ног у наземного животного");
    УзелНоги = СоздатьУзел("Узел - количество ног наземного животного", ВопросНоги);
    
    // Связь: Нет -> переход к вопросу о ногах
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелНоги, ВопросНоги, Ложь);
    
    // Ветка для четвероногих животных (ответ "Да" на вопрос о ногах)
    СоздатьВеткуЧетвероногих(Тест, УзелНоги);
    
    // Ветка для не четвероногих животных (ответ "Нет" на вопрос о ногах)
    СоздатьВеткуНеЧетвероногих(Тест, УзелНоги);
    
КонецПроцедуры

// Создает ветку маленьких водных животных
Процедура СоздатьВеткуМаленькихВодных(Тест, РодительскийУзел) Экспорт
    
    // Уровень 2: Вопрос о наличии чешуи для маленьких водных
    ВопросЧешуя = СоздатьВопрос("У него есть чешуя?", "Определяет тип маленького водного животного");
    УзелЧешуя = СоздатьУзел("Узел - чешуя у маленького животного", ВопросЧешуя);
    
    // Связь: Нет -> переход к вопросу о чешуе
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелЧешуя, ВопросЧешуя, Ложь);
    
    // РЫБА (Да -> Есть чешуя -> Рыба)
    ВопросРыба = СоздатьВопрос("Это рыба?", "Финальный вопрос для рыбы");
    УзелРыба = СоздатьУзел("Узел - рыба", ВопросРыба);
    ЗаписатьУзелДереваВТест(Тест, УзелЧешуя, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелРыба, ВопросРыба, Истина);
    
    // ОСЬМИНОГ (Нет -> Нет чешуи -> Осьминог)
    ВопросОсьминог = СоздатьВопрос("Это осьминог?", "Финальный вопрос для осьминога");
    УзелОсьминог = СоздатьУзел("Узел - осьминог", ВопросОсьминог);
    ЗаписатьУзелДереваВТест(Тест, УзелЧешуя, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелОсьминог, ВопросОсьминог, Истина);
    
КонецПроцедуры

// Создает ветку четвероногих животных
Процедура СоздатьВеткуЧетвероногих(Тест, РодительскийУзел) Экспорт
    
    // Уровень 2: Вопрос о хищнике для четвероногих
    ВопросХищник = СоздатьВопрос("Оно хищник?", "Определяет тип четвероногого животного");
    УзелХищник = СоздатьУзел("Узел - хищник четвероногое", ВопросХищник);
    
    // Связь: Да -> переход к вопросу о хищнике
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелХищник, ВопросХищник, Ложь);
    
    // ЛЕВ (Да -> Хищник -> Лев)
    ВопросЛев = СоздатьВопрос("Это лев?", "Финальный вопрос для льва");
    УзелЛев = СоздатьУзел("Узел - лев", ВопросЛев);
    ЗаписатьУзелДереваВТест(Тест, УзелХищник, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелЛев, ВопросЛев, Истина);
    
    // СОБАКА (Нет -> Не хищник -> Собака)
    ВопросСобака = СоздатьВопрос("Это собака?", "Финальный вопрос для собаки");
    УзелСобака = СоздатьУзел("Узел - собака", ВопросСобака);
    ЗаписатьУзелДереваВТест(Тест, УзелХищник, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелСобака, ВопросСобака, Истина);
    
КонецПроцедуры

// Создает ветку не четвероногих животных
Процедура СоздатьВеткуНеЧетвероногих(Тест, РодительскийУзел) Экспорт
    
    // Уровень 2: Вопрос о наличии крыльев для не четвероногих
    ВопросКрылья = СоздатьВопрос("У него есть крылья?", "Определяет тип не четвероногого животного");
    УзелКрылья = СоздатьУзел("Узел - крылья не четвероногое", ВопросКрылья);
    
    // Связь: Нет -> переход к вопросу о крыльях
    ЗаписатьУзелДереваВТест(Тест, РодительскийУзел, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелКрылья, ВопросКрылья, Ложь);
    
    // ПТИЦА (Да -> Есть крылья -> Птица)
    ВопросПтица = СоздатьВопрос("Это птица?", "Финальный вопрос для птицы");
    УзелПтица = СоздатьУзел("Узел - птица", ВопросПтица);
    ЗаписатьУзелДереваВТест(Тест, УзелКрылья, Перечисления.ТипыОтветовБинарногоДерева.Да, УзелПтица, ВопросПтица, Истина);
    
    // ЗМЕЯ (Нет -> Нет крыльев -> Змея)
    ВопросЗмея = СоздатьВопрос("Это змея?", "Финальный вопрос для змеи");
    УзелЗмея = СоздатьУзел("Узел - змея", ВопросЗмея);
    ЗаписатьУзелДереваВТест(Тест, УзелКрылья, Перечисления.ТипыОтветовБинарногоДерева.Нет, УзелЗмея, ВопросЗмея, Истина);
    
КонецПроцедуры

// Записывает текущий вопрос
Процедура ЗаписатьТекущийВопрос(Тест, СледующийУзел) Экспорт
    
    Если Тест.Завершен Тогда
        Возврат;
    КонецЕсли;

    Если СледующийУзел = Неопределено Тогда
        Тест.Завершен = Истина;
        Тест.ВремяЗавершения = ТекущаяДата();
        Тест.РезультатСдачи = Перечисления.РезультатыСдачи.Сдан;
        Тест.ПроцентЗавершения = 100; // ⭐ Устанавливаем 100% при завершении
        Сообщить("   Тест завершен: достигнут неопределенный узел");
        Возврат;
    КонецЕсли;
    
    Тест.ТекущийУзелДерева = СледующийУзел.Ссылка;
    
    // Записываем вопрос в табличную часть
    ЗаписатьВопросВТабличнуюЧасть(Тест, СледующийУзел.Ссылка);
    
    // Обновляем счетчик вопросов
    Тест.КоличествоВопросов = Тест.КоличествоВопросов + 1;
    Сообщить("   Количество вопросов обновлено: " + Тест.КоличествоВопросов);
    
    // Проверяем, является ли узел листом
    Если СледующийУзел.ЯвляетсяЛистом Тогда
        Тест.Завершен = Истина;
        Тест.ВремяЗавершения = ТекущаяДата();
        Тест.РезультатСдачи = Перечисления.РезультатыСдачи.Сдан;
        Тест.ПроцентЗавершения = 100; // ⭐ Устанавливаем 100% при достижении листа
        Сообщить("   ✅ ТЕСТ ЗАВЕРШЕН: Достигнут листовой узел: " + СледующийУзел.Наименование);
    КонецЕсли;
    
КонецПроцедуры

// Исправленная функция записи вопроса в табличную часть
Процедура ЗаписатьВопросВТабличнуюЧасть(Тест, УзелДерева) Экспорт
    
    Если УзелДерева = Неопределено ИЛИ УзелДерева.Вопрос = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    // Проверяем, не добавлен ли уже этот вопрос
    Если ВопросУжеДобавлен(Тест, УзелДерева.Вопрос) Тогда
        Сообщить("   Вопрос уже добавлен: " + УзелДерева.Вопрос.ТекстФормулировки);
        Возврат;
    КонецЕсли;
    
    // Добавляем вопрос в табличную часть
    НоваяСтрока = Тест.ВопросыБинарногоДерева.Добавить();
    НоваяСтрока.Вопрос = УзелДерева.Вопрос;
    
    // ⭐ Нужно определить раздел - временное решение
    Попытка
        НоваяСтрока.Раздел = НайтиРазделДляВопроса(УзелДерева.Вопрос);
    Исключение
        Сообщить("   ⚠️ Не удалось установить раздел для вопроса");
        // Продолжаем без раздела - это не критично для теста
    КонецПопытки;
    
    НоваяСтрока.Правильность = 0;
    НоваяСтрока.ОтветПолучен = Ложь;
    НоваяСтрока.Проверен = Ложь;
    
    Сообщить("   Вопрос добавлен в табличную часть: " + УзелДерева.Вопрос.ТекстФормулировки);
    Сообщить("   Всего вопросов: " + Тест.ВопросыБинарногоДерева.Количество());
    
КонецПроцедуры

// Безопасная функция поиска раздела
Функция НайтиРазделДляВопроса(Вопрос) Экспорт
    
    Попытка
        // Временное решение - находим любой раздел
        Запрос = Новый Запрос;
        Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1 Ссылка ИЗ Справочник.Разделы";
        Результат = Запрос.Выполнить();
        Выборка = Результат.Выбрать();
        Если Выборка.Следующий() Тогда
            Возврат Выборка.Ссылка;
        КонецЕсли;
        
        // Если разделов нет - создаем временный
        Возврат СоздатьВременныйРаздел();
    Исключение
        Сообщить("   ⚠️ Ошибка при поиске раздела: " + ОписаниеОшибки());
        Возврат Неопределено;
    КонецПопытки;
    
КонецФункции

// Проверка, добавлен ли уже вопрос
Функция ВопросУжеДобавлен(Тест, Вопрос) Экспорт
    
    Если Вопрос = Неопределено Тогда
        Возврат Истина;
    КонецЕсли;
    
    Для Каждого Строка Из Тест.ВопросыБинарногоДерева Цикл
        Если Строка.Вопрос = Вопрос Тогда
            Возврат Истина;
        КонецЕсли;
    КонецЦикла;
    
    Возврат Ложь;
    
КонецФункции

Функция СоздатьВременныйРаздел() Экспорт
    Раздел = Справочники.Разделы.СоздатьЭлемент();
    Раздел.Наименование = "Временный раздел для бинарного дерева";
    Раздел.Записать();
    Возврат Раздел.Ссылка;
КонецФункции

#КонецОбласти


#Область РаботаСРегистрами

// Загружает структуру дерева из регистра в документ теста.
// Является внутренней, вызывается из ЗаполнитьТестИзШаблона.
Процедура ЗагрузитьСтруктуруДереваИзРегистра(Тест, ШаблонТеста) // Убрано "Экспорт"
    
    // Этот код уже идеален, он выполняет одну задачу. Ничего не меняем.
    Запрос = Новый Запрос;
    Запрос.Текст = 
        "ВЫБРАТЬ
        |	Структура.РодительскийУзел,
        |	Структура.ТипОтвета КАК ТипСвязи,
        |	Структура.СледующийУзелДерева КАК УзелДерева,
        |	УзелСправочник.Вопрос,
        |	УзелСправочник.Уровень,
        |	УзелСправочник.ЯвляетсяЛистом,
        |	Структура.СостояниеСвязи = ЗНАЧЕНИЕ(Перечисление.СостоянияСвязиБинарногоДерева.СвязьАктивна) КАК Активность,
        |	0 КАК Порядок
        |ИЗ
        |	РегистрСведений.СтруктураБинарногоДерева КАК Структура
        |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК УзелСправочник
        |		ПО Структура.СледующийУзелДерева = УзелСправочник.Ссылка
        |ГДЕ
        |	Структура.ШаблонТеста = &ШаблонТеста";
        
    Запрос.УстановитьПараметр("ШаблонТеста", ШаблонТеста);
    
    Тест.СтруктураДереваТеста.Загрузить(Запрос.Выполнить().Выгрузить());
    Сообщить("Структура бинарного дерева загружена из регистра. Узлов: " + Тест.СтруктураДереваТеста.Количество());
    
КонецПроцедуры

// Универсальная процедура для заполнения документа теста данными из шаблона.
Процедура ЗаполнитьТестИзШаблона(Тест) Экспорт
    
    ШаблонТеста = Тест.ШаблонТеста;
    Если НЕ ЗначениеЗаполнено(ШаблонТеста) Тогда
        Сообщить("Предупреждение: Шаблон теста не указан, заполнение отменено.");
        Возврат;
    КонецЕсли;

    Сообщить("Загрузка структуры для шаблона: " + ШаблонТеста.Наименование);
    
    Тест.ТипТестирования = Перечисления.ТипыТестирования.БинарноеДерево;
    Тест.СтруктураДереваТеста.Очистить();
    Тест.ВопросыБинарногоДерева.Очистить();
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
        "ВЫБРАТЬ
        |    Структура.РодительскийУзел,
        |    Структура.ТипОтвета КАК ТипСвязи,
        |    Структура.СледующийУзелДерева КАК УзелДерева,
        |    УзелСправочник.Вопрос,
        |    УзелСправочник.Уровень,
        |    УзелСправочник.ЯвляетсяЛистом,
        |    (Структура.СостояниеСвязи = ЗНАЧЕНИЕ(Перечисление.СостоянияСвязиБинарногоДерева.СвязьАктивна)) КАК Активность,
        |    0 КАК Порядок
        |ИЗ
        |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
        |        ЛЕВОЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК УзелСправочник
        |        ПО Структура.СледующийУзелДерева = УзелСправочник.Ссылка
        |ГДЕ
        |    Структура.ШаблонТеста = &ШаблонТеста";
        
    Запрос.УстановитьПараметр("ШаблонТеста", ШаблонТеста);
    
    Сообщить("Выполняем запрос к регистру...");
    Результат = Запрос.Выполнить();
    Сообщить("Запрос выполнен, количество записей: " + Результат.Выбрать().Количество());
    
    Выборка = Результат.Выбрать();
    КоличествоЗаписей = 0;
    
    Пока Выборка.Следующий() Цикл
        НоваяСтрока = Тест.СтруктураДереваТеста.Добавить();
        НоваяСтрока.РодительскийУзел = Выборка.РодительскийУзел;
        НоваяСтрока.ТипСвязи = Выборка.ТипСвязи;
        НоваяСтрока.УзелДерева = Выборка.УзелДерева;
        НоваяСтрока.Вопрос = Выборка.Вопрос;
        НоваяСтрока.Уровень = Выборка.Уровень;
        НоваяСтрока.ЯвляетсяЛистом = Выборка.ЯвляетсяЛистом;
        НоваяСтрока.Активность = Выборка.Активность;
        НоваяСтрока.Порядок = Выборка.Порядок;
        КоличествоЗаписей = КоличествоЗаписей + 1;
        
        Если КоличествоЗаписей <= 3 Тогда // Показываем первые 3 записи для диагностики
            Сообщить("   Загружена запись: " + 
                ?(Выборка.УзелДерева = Неопределено, "НЕОПР", Выборка.УзелДерева.Наименование) + 
                ", Родитель: " + ?(Выборка.РодительскийУзел = Неопределено, "КОРЕНЬ", Выборка.РодительскийУзел.Наименование));
        КонецЕсли;
    КонецЦикла;
    
    Сообщить("Структура бинарного дерева загружена из регистра. Узлов: " + КоличествоЗаписей);
    
КонецПроцедуры

// Добавить в область ВспомогательныеПроцедурыДляРегистров

// Диагностическая процедура для проверки данных в регистре состояния
Процедура ПроверитьДанныеВРегистреСостояния(Тест) Экспорт
    Сообщить("=== ДИАГНОСТИКА РЕГИСТРА СОСТОЯНИЯ ===");
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Состояние.Тест,
    |    Состояние.ТекущийУзел,
    |    Состояние.ДеревоВопросов
    |ИЗ
    |    РегистрСведений.СостояниеБинарногоДерева КАК Состояние
    |ГДЕ
    |    Состояние.Тест = &Тест";
    
    Запрос.УстановитьПараметр("Тест", Тест.Ссылка);
    Результат = Запрос.Выполнить();
    Выборка = Результат.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Сообщить("Найдена запись в регистре состояния:");
        Сообщить("   Тест: " + Выборка.Тест);
        Сообщить("   ТекущийУзел: " + ?(Выборка.ТекущийУзел = Неопределено, "Неопределено", Выборка.ТекущийУзел.Наименование));
        Сообщить("   ДеревоВопросов: " + ?(Выборка.ДеревоВопросов = Неопределено, "Неопределено", "Заполнено"));
    Иначе
        Сообщить("Запись в регистре состояния НЕ НАЙДЕНА!");
    КонецЕсли;
КонецПроцедуры

// Процедура для создания минимального тестового дерева
Процедура СоздатьМинимальноеДеревоДляТеста(Тест) Экспорт
    Сообщить("Создание минимального дерева для теста...");
    
    // Очищаем существующую структуру
    Тест.СтруктураДереваТеста.Очистить();
    
    // Создаем корневой вопрос и узел
    КорневойВопрос = СоздатьВопрос("Корневой вопрос?", "Тестовый корневой вопрос");
    КорневойУзел = СоздатьУзел("Корневой узел", КорневойВопрос);
    
    // Записываем корневой узел
    ЗаписатьУзелДереваВТест(Тест, Неопределено, Неопределено, КорневойУзел, КорневойВопрос, Ложь);
    
    // Создаем дочерний вопрос и узел
    ДочернийВопрос = СоздатьВопрос("Дочерний вопрос?", "Тестовый дочерний вопрос");
    ДочернийУзел = СоздатьУзел("Дочерний узел", ДочернийВопрос);
    
    // Записываем дочерний узел с ответом "Нет"
    ЗаписатьУзелДереваВТест(Тест, КорневойУзел.Ссылка, Перечисления.ТипыОтветовБинарногоДерева.Нет, 
                            ДочернийУзел, ДочернийВопрос, Ложь);
    
    Сообщить("Минимальное дерево создано: 2 узла");
КонецПроцедуры

Процедура СохранитьОтветыВРегистр(Тест) Экспорт
    
    Если Тест = Неопределено Или Тест.Ссылка.Пустая() Тогда
        Возврат;
    КонецЕсли;
    
    Попытка
        НаборЗаписей = РегистрыСведений.ОтветыНаВопросыТестов.СоздатьНаборЗаписей();
        НаборЗаписей.Отбор.Тест.Установить(Тест.Ссылка);
        
        Для Каждого ОтветСтрока Из Тест.ОтветыБинарногоДерева Цикл
            // ⭐ УСИЛЕННАЯ ПРОВЕРКА ПЕРЕД ДОБАВЛЕНИЕМ В РЕГИСТР
            Если ОтветСтрока.УзелДерева <> Неопределено 
               И ОтветСтрока.Вопрос <> Неопределено Тогда
                
                НоваяЗапись = НаборЗаписей.Добавить();
                НоваяЗапись.Тест = Тест.Ссылка;
                
                Раздел = ПолучитьРазделДляУзла(ОтветСтрока.УзелДерева);
                Если Раздел = Неопределено Тогда
                    Раздел = ПредопределенноеЗначение("Справочник.Разделы.ПустаяСсылка");
                КонецЕсли;
                НоваяЗапись.Раздел = Раздел;
                
                НоваяЗапись.Вопрос = ОтветСтрока.Вопрос;
                НоваяЗапись.ОтветПолучен = Истина;
                НоваяЗапись.Правильность = РассчитатьПравильностьОтветаДляРегистра(ОтветСтрока);
                НоваяЗапись.ВремяОтвета = ОтветСтрока.ВремяОтвета;
                
                Сообщить("   Добавлен ответ в регистр: " + ОтветСтрока.Вопрос.ТекстФормулировки);
            Иначе
                Сообщить("   ПРЕДУПРЕЖДЕНИЕ: Пропущен ответ с пустым узлом или вопросом");
            КонецЕсли;
        КонецЦикла;
        
        Если НаборЗаписей.Количество() > 0 Тогда
            НаборЗаписей.Записать();
            Сообщить("Ответы сохранены в независимый регистр: " + НаборЗаписей.Количество() + " записей");
        КонецЕсли;
        
    Исключение
        Сообщить("Ошибка сохранения ответов в регистр: " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры

// Получает статистику ответов из регистра
Функция ПолучитьСтатистикуОтветов(Тест) Экспорт
    
    Результат = Новый Структура;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    ОтветыНаВопросыТестов.Вопрос,
    |    ОтветыНаВопросыТестов.ОтветПолучен,
    |    ОтветыНаВопросыТестов.Правильность
    |ИЗ
    |    РегистрСведений.ОтветыНаВопросыТестов КАК ОтветыНаВопросыТестов
    |ГДЕ
    |    ОтветыНаВопросыТестов.Тест = &Тест";
    
    Запрос.УстановитьПараметр("Тест", Тест.Ссылка);
    РезультатЗапроса = Запрос.Выполнить();
    Выборка = РезультатЗапроса.Выбрать();
    
    ВсегоОтветов = 0;
    ПравильныхОтветов = 0;
    
    Пока Выборка.Следующий() Цикл
        ВсегоОтветов = ВсегоОтветов + 1;
        Если Выборка.Правильность > 0 Тогда
            ПравильныхОтветов = ПравильныхОтветов + 1;
        КонецЕсли;
    КонецЦикла;
    
    Результат.Вставить("ВсегоОтветов", ВсегоОтветов);
    Результат.Вставить("ПравильныхОтветов", ПравильныхОтветов);
    Результат.Вставить("ПроцентПравильных", 
        ?(ВсегоОтветов > 0, Окр(ПравильныхОтветов / ВсегоОтветов * 100, 2), 0));
    
    Возврат Результат;
    
КонецФункции

#КонецОбласти

#Область БазаЗнаний

// Создает регистр сведений БазаЗнаний
Процедура ИнициализироватьБазуЗнаний() Экспорт
    
    // Структура регистра:
    // Измерения: Вопрос, Ответ, УзелДерева, Тест
    // Ресурсы: КоличествоИспользований, ПроцентПравильности, ДатаПоследнегоИспользования
    
    Сообщить("База знаний инициализирована");
    
КонецПроцедуры

// Добавляет запись в базу знаний
Процедура ДобавитьВБазуЗнаний(Тест, Узел, Ответ, Правильность) Экспорт
    
    Если Тест = Неопределено Или Узел = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    Попытка
        НаборЗаписей = РегистрыСведений.БазаЗнаний.СоздатьНаборЗаписей();
        
        // ⭐ УСТАНАВЛИВАЕМ ОТБОР ПО КЛЮЧЕВЫМ ИЗМЕРЕНИЯМ
        НаборЗаписей.Отбор.Вопрос.Установить(Узел.Вопрос);
        НаборЗаписей.Отбор.Ответ.Установить(Ответ);
        НаборЗаписей.Отбор.УзелДерева.Установить(Узел.Ссылка);
		НаборЗаписей.Прочитать();
        Если НаборЗаписей.Количество() > 0 Тогда
            // Обновляем существующую
            НоваяЗапись = НаборЗаписей[0];
            БылСчетчик = НоваяЗапись.КоличествоИспользований;
            БылПроцент = НоваяЗапись.ПроцентПравильности;
            НоваяЗапись.КоличествоИспользований = БылСчетчик + 1;
            НоваяЗапись.ПроцентПравильности = (БылПроцент * БылСчетчик + Правильность) / НоваяЗапись.КоличествоИспользований;
            НоваяЗапись.ДатаПоследнегоИспользования = ТекущаяДата();
            НоваяЗапись.Тест = Тест.Ссылка;  // Обновляем Тест, если нужно
	        НаборЗаписей.Записать();
	        
	        Сообщить("   Данные обновлены в базе знаний для вопроса: " + Узел.Вопрос.ТекстФормулировки);
        Иначе
	        // ⭐ ДОБАВЛЯЕМ НОВУЮ ЗАПИСЬ - старая с такими же измерениями автоматически заместится
	        НоваяЗапись = НаборЗаписей.Добавить();
	        НоваяЗапись.Вопрос = Узел.Вопрос;
	        НоваяЗапись.Ответ = Ответ;
	        НоваяЗапись.УзелДерева = Узел.Ссылка;
	        НоваяЗапись.Тест = Тест.Ссылка;
	        НоваяЗапись.КоличествоИспользований = 1;
	        НоваяЗапись.ПроцентПравильности = Правильность;
	        НоваяЗапись.ДатаПоследнегоИспользования = ТекущаяДата();
	        
	        НаборЗаписей.Записать();
	        
	        Сообщить("   Данные добавлены в базу знаний для вопроса: " + Узел.Вопрос.ТекстФормулировки);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка добавления в базу знаний: " + ОписаниеОшибки());
    КонецПопытки;
    
КонецПроцедуры

// Получает статистику по вопросу
Функция ПолучитьСтатистикуПоВопросу(Вопрос) Экспорт
    
    Результат = Новый Структура;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |	БазаЗнаний.Вопрос,
    |	СУММА(БазаЗнаний.КоличествоИспользований) КАК ВсегоИспользований,
    |	СУММА(БазаЗнаний.ПроцентПравильности * БазаЗнаний.КоличествоИспользований) / СУММА(БазаЗнаний.КоличествоИспользований) КАК СредняяПравильность,
    |	МАКСИМУМ(БазаЗнаний.ДатаПоследнегоИспользования) КАК ДатаПоследнегоИспользования
    |ИЗ
    |	РегистрСведений.БазаЗнаний КАК БазаЗнаний
    |ГДЕ
    |	БазаЗнаний.Вопрос = &Вопрос
    |
    |СГРУППИРОВАТЬ ПО
    |	БазаЗнаний.Вопрос";
    
    Запрос.УстановитьПараметр("Вопрос", Вопрос);
    РезультатЗапроса = Запрос.Выполнить();
    Выборка = РезультатЗапроса.Выбрать();
    
    Если Выборка.Следующий() Тогда
        Результат.Вставить("ВсегоИспользований", Выборка.ВсегоИспользований);
        Результат.Вставить("СредняяПравильность", Окр(Выборка.СредняяПравильность, 2));
        Результат.Вставить("ДатаПоследнегоИспользования", Выборка.ДатаПоследнегоИспользования);
    Иначе
        Результат.Вставить("ВсегоИспользований", 0);
        Результат.Вставить("СредняяПравильность", 0);
        Результат.Вставить("ДатаПоследнегоИспользования", Неопределено);
    КонецЕсли;
    
    Возврат Результат;
    
КонецФункции

// Получает наиболее проблемные вопросы
Функция ПолучитьПроблемныеВопросы(Лимит = 10) Экспорт
    
    Результат = Новый Массив;
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ ПЕРВЫЕ " + Лимит + "
    |    БазаЗнаний.Вопрос,
    |    СУММА(БазаЗнаний.КоличествоИспользований) КАК ВсегоИспользований,
    |    СРЕДНЕЕ(БазаЗнаний.ПроцентПравильности) КАК СредняяПравильность
    |ИЗ
    |    РегистрСведений.БазаЗнаний КАК БазаЗнаний
    |СГРУППИРОВАТЬ ПО
    |    БазаЗнаний.Вопрос
    |УПОРЯДОЧИТЬ ПО
    |    СредняяПравильность";
    
    РезультатЗапроса = Запрос.Выполнить();
    Выборка = РезультатЗапроса.Выбрать();
    
    Пока Выборка.Следующий() Цикл
        ВопросСтатистика = Новый Структура;
        ВопросСтатистика.Вставить("Вопрос", Выборка.Вопрос);
        ВопросСтатистика.Вставить("ВсегоИспользований", Выборка.ВсегоИспользований);
        ВопросСтатистика.Вставить("СредняяПравильность", Окр(Выборка.СредняяПравильность, 2));
        Результат.Добавить(ВопросСтатистика);
    КонецЦикла;
    
    Возврат Результат;
    
КонецФункции

// Обновляет базу знаний при обработке ответа
Процедура ОбновитьБазуЗнанийПриОтвете(Тест, Узел, Ответ) Экспорт
    
    Если Узел = Неопределено Тогда
        Возврат;
    КонецЕсли;
    
    // Рассчитываем правильность (для бинарного дерева - 1 если достигнут лист)
    Правильность = ?(Узел.ЯвляетсяЛистом, 1, 0);
    
    // Добавляем в базу знаний
    ДобавитьВБазуЗнаний(Тест, Узел, Ответ, Правильность);
    
КонецПроцедуры

#КонецОбласти


#Область ВспомогательныеПроцедурыДляРегистров

// Очищает регистр структуры дерева для шаблона
Процедура ОчиститьРегистрСтруктурыДереваДляШаблона(ШаблонТеста) Экспорт
    
    НаборЗаписей = РегистрыСведений.СтруктураБинарногоДерева.СоздатьНаборЗаписей();
    
    // ⭐ ПРАВИЛЬНЫЙ СПОСОБ: Устанавливаем отбор по шаблону
    НаборЗаписей.Отбор.ШаблонТеста.Установить(ШаблонТеста);
    
    // Записываем пустой набор - удалятся только записи с этим шаблоном
    НаборЗаписей.Записать();
    
    Сообщить("Очищены записи регистра для шаблона: " + ШаблонТеста.Наименование);
    
КонецПроцедуры

Функция СформироватьДеревоВопросовJSON(Тест) Экспорт
	
	Попытка
		Дерево = Новый Соответствие;
		Узлы = Новый Массив;
		
		// Собираем информацию об узлах
		Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
			Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
				Узел = Новый Структура;
				Узел.Вставить("Идентификатор", Строка(СтрокаСтруктуры.УзелДерева.УникальныйИдентификатор()));
				Узел.Вставить("Наименование", СтрокаСтруктуры.УзелДерева.Наименование);
				Узел.Вставить("Родитель", ?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "", Строка(СтрокаСтруктуры.РодительскийУзел.УникальныйИдентификатор())));
				Узел.Вставить("ТипСвязи", Строка(СтрокаСтруктуры.ТипСвязи));
				Узел.Вставить("Уровень", СтрокаСтруктуры.Уровень);
				Узел.Вставить("ЯвляетсяЛистом", СтрокаСтруктуры.ЯвляетсяЛистом);
				Узлы.Добавить(Узел);
			КонецЕсли;
		КонецЦикла;
		
		// Собираем информацию о табличной части вопросов
		ВопросыТЧ = Новый Массив;
		Для Каждого СтрокаВопроса Из Тест.ВопросыБинарногоДерева Цикл
			Если СтрокаВопроса.Вопрос <> Неопределено Тогда
				Вопрос = Новый Структура;
				Вопрос.Вставить("Идентификатор", Строка(СтрокаВопроса.Вопрос.УникальныйИдентификатор()));
				Вопрос.Вставить("Текст", СтрокаВопроса.Вопрос.ТекстФормулировки);
				Вопрос.Вставить("Раздел", ?(СтрокаВопроса.Раздел = Неопределено, "", Строка(СтрокаВопроса.Раздел.УникальныйИдентификатор())));
				Вопрос.Вставить("Правильность", СтрокаВопроса.Правильность);
				Вопрос.Вставить("ОтветПолучен", СтрокаВопроса.ОтветПолучен);
				ВопросыТЧ.Добавить(Вопрос);
			КонецЕсли;
		КонецЦикла;
		
		Дерево.Вставить("Узлы", Узлы);
		Дерево.Вставить("ВопросыТЧ", ВопросыТЧ);
		Дерево.Вставить("ТекущийУзел", ?(Тест.ТекущийУзелДерева = Неопределено, "", Строка(Тест.ТекущийУзелДерева.УникальныйИдентификатор())));
		Дерево.Вставить("ВремяСохранения", Формат(ТекущаяДата(), "ДФ=yyyy-MM-dd HH:mm:ss"));
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, "  "));
		ЗаписатьJSON(ЗаписьJSON, Дерево);
		JSONСтрока = ЗаписьJSON.Закрыть();
		
		// ⭐ ПРЕОБРАЗУЕМ В ХРАНИЛИЩЕЗНАЧЕНИЯ
		Хранилище = Новый ХранилищеЗначения(JSONСтрока);
		Возврат Хранилище;
		
	Исключение
		Сообщить("Ошибка при формировании JSON: " + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;	
КонецФункции

// Формирует данные дерева для сохранения в ХранилищеЗначения
Функция СформироватьДанныеДереваДляХранилища(Тест) Экспорт
	
	Попытка
		Данные = Новый Структура;
		Узлы = Новый Массив;
		
		// Собираем информацию об узлах
		Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
			Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
				Узел = Новый Структура;
				Узел.Вставить("Идентификатор", Строка(СтрокаСтруктуры.УзелДерева.УникальныйИдентификатор()));
				Узел.Вставить("Наименование", СтрокаСтруктуры.УзелДерева.Наименование);
				Узел.Вставить("Родитель", ?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "", Строка(СтрокаСтруктуры.РодительскийУзел.УникальныйИдентификатор())));
				Узел.Вставить("ТипСвязи", Строка(СтрокаСтруктуры.ТипСвязи));
				Узел.Вставить("Уровень", СтрокаСтруктуры.Уровень);
				Узел.Вставить("ЯвляетсяЛистом", СтрокаСтруктуры.ЯвляетсяЛистом);
				Узлы.Добавить(Узел);
			КонецЕсли;
		КонецЦикла;
		
		// Собираем информацию о табличной части вопросов
		ВопросыТЧ = Новый Массив;
		Для Каждого СтрокаВопроса Из Тест.ВопросыБинарногоДерева Цикл
			Если СтрокаВопроса.Вопрос <> Неопределено Тогда
				Вопрос = Новый Структура;
				Вопрос.Вставить("Идентификатор", Строка(СтрокаВопроса.Вопрос.УникальныйИдентификатор()));
				Вопрос.Вставить("Текст", СтрокаВопроса.Вопрос.ТекстФормулировки);
				Вопрос.Вставить("Раздел", ?(СтрокаВопроса.Раздел = Неопределено, "", Строка(СтрокаВопроса.Раздел.УникальныйИдентификатор())));
				Вопрос.Вставить("Правильность", СтрокаВопроса.Правильность);
				Вопрос.Вставить("ОтветПолучен", СтрокаВопроса.ОтветПолучен);
				ВопросыТЧ.Добавить(Вопрос);
			КонецЕсли;
		КонецЦикла;
		
		Данные.Вставить("Узлы", Узлы);
		Данные.Вставить("ВопросыТЧ", ВопросыТЧ);
		// ⭐ ИСПРАВЛЕНИЕ: Проверка на Неопределено ИЛИ ПустаяСсылка()
		Данные.Вставить("ТекущийУзел", ?(Тест.ТекущийУзелДерева = Неопределено ИЛИ Тест.ТекущийУзелДерева.Пустая(), "NONE", Строка(Тест.ТекущийУзелДерева.УникальныйИдентификатор())));
		Данные.Вставить("ВремяСохранения", ТекущаяДата());
		
		// ⭐ ПРАВИЛЬНОЕ СОЗДАНИЕ ХРАНИЛИЩАЗНАЧЕНИЯ
		Хранилище = Новый ХранилищеЗначения(Данные);
		Возврат Хранилище;
		
	Исключение
		Сообщить("Ошибка при формировании данных для хранилища: " + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;	
КонецФункции

// Восстанавливает дерево вопросов из ХранилищаЗначения
Процедура ВосстановитьДеревоВопросовИзХранилища(Тест, ХранилищеДанных) Экспорт
	Если ХранилищеДанных = Неопределено Тогда
		Сообщить("   ⚠️ Хранилище данных неопределено - пропускаем восстановление");
		Возврат;
	КонецЕсли;
	Попытка
		// ⭐ ПРАВИЛЬНОЕ ПОЛУЧЕНИЕ ДАННЫХ ИЗ ХРАНИЛИЩАЗНАЧЕНИЯ
		Данные = ХранилищеДанных.Получить();
		Если Данные = Неопределено Тогда
			Сообщить("   ⚠️ Не удалось получить данные из хранилища");
			Возврат;
		КонецЕсли;
		// Восстанавливаем текущий узел
		Если Данные.Свойство("ТекущийУзел") Тогда
			Если Данные.ТекущийУзел = "NONE" ИЛИ Данные.ТекущийУзел = "00000000-0000-0000-0000-000000000000" Тогда
				Тест.ТекущийУзелДерева = Неопределено;
			ИначеЕсли Не ПустаяСтрока(Данные.ТекущийУзел) Тогда
				Попытка
					Узел = НайтиУзелПоИдентификатору(Данные.ТекущийУзел);
					Если Узел <> Неопределено Тогда
						Тест.ТекущийУзелДерева = Узел.Ссылка;
						Сообщить("   ✓ Восстановлен текущий узел: " + Узел.Наименование);
					Иначе
						Сообщить("   ⚠️ Не удалось найти узел по идентификатору: " + Данные.ТекущийУзел);
					КонецЕсли;
				Исключение
					Сообщить("   ⚠️ Ошибка при восстановлении текущего узла: " + ОписаниеОшибки());
					Тест.ТекущийУзелДерева = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		// Восстанавливаем табличную часть вопросов
		Если Данные.Свойство("ВопросыТЧ") Тогда
			Тест.ВопросыБинарногоДерева.Очистить();
			Для Каждого ВопросДанные Из Данные.ВопросыТЧ Цикл
				Вопрос = НайтиВопросПоИдентификатору(ВопросДанные.Идентификатор);
				Если Вопрос <> Неопределено Тогда
					НоваяСтрока = Тест.ВопросыБинарногоДерева.Добавить();
					НоваяСтрока.Вопрос = Вопрос.Ссылка;
					// Восстанавливаем раздел
					Если Не ПустаяСтрока(ВопросДанные.Раздел) И ВопросДанные.Раздел <> "00000000-0000-0000-0000-000000000000" Тогда
						Раздел = НайтиРазделПоИдентификатору(ВопросДанные.Раздел);
						Если Раздел <> Неопределено Тогда
							НоваяСтрока.Раздел = Раздел.Ссылка;
						КонецЕсли;
					КонецЕсли;
					НоваяСтрока.Правильность = ВопросДанные.Правильность;
					НоваяСтрока.ОтветПолучен = ВопросДанные.ОтветПолучен;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Сообщить("   ✓ Дерево вопросов восстановлено из хранилища");
	Исключение
		Сообщить("   ⚠️ Ошибка при восстановлении дерева из хранилища: " + ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

// Находит вопрос по идентификатору
Функция НайтиВопросПоИдентификатору(Идентификатор) Экспорт
	Попытка
		УникальныйИД = Новый УникальныйИдентификатор(Идентификатор);
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|    Вопросы.Ссылка
		|ИЗ
		|    ПланВидовХарактеристик.ВопросыДляТестирования КАК Вопросы
		|ГДЕ
		|    Вопросы.Ссылка = &Идентификатор";
		Запрос.УстановитьПараметр("Идентификатор", УникальныйИД);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Ссылка.ПолучитьОбъект();
		КонецЕсли;
	Исключение
		// Если возникла ошибка - возвращаем неопределено
	КонецПопытки;
	Возврат Неопределено;
КонецФункции

// Находит раздел по идентификатору
Функция НайтиРазделПоИдентификатору(Идентификатор) Экспорт
	Попытка
		УникальныйИД = Новый УникальныйИдентификатор(Идентификатор);
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|    Разделы.Ссылка
		|ИЗ
		|    Справочник.Разделы КАК Разделы
		|ГДЕ
		|    Разделы.Ссылка = &Идентификатор";
		Запрос.УстановитьПараметр("Идентификатор", УникальныйИД);
		Результат = Запрос.Выполнить();
		Выборка = Результат.Выбрать();
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Ссылка.ПолучитьОбъект();
		КонецЕсли;
	Исключение
		// Если возникла ошибка - возвращаем неопределено
	КонецПопытки;
	Возврат Неопределено;
КонецФункции

// Формирует XML структуру дерева вопросов (альтернатива JSON)
Функция СформироватьДеревоВопросовXML(Тест) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ЗаписьXML.ЗаписатьНачалоЭлемента("ДеревоВопросов");
	// Записываем информацию о текущем узле
	Если Тест.ТекущийУзелДерева <> Неопределено Тогда
		ЗаписьXML.ЗаписатьНачалоЭлемента("ТекущийУзел");
		ЗаписьXML.ЗаписатьАтрибут("Идентификатор", Тест.ТекущийУзелДерева.УникальныйИдентификатор());
		ЗаписьXML.ЗаписатьАтрибут("Наименование", Тест.ТекущийУзелДерева.Наименование);
		ЗаписьXML.ЗаписатьКонецЭлемента(); // ТекущийУзел
	КонецЕсли;
	// Записываем узлы
	ЗаписьXML.ЗаписатьНачалоЭлемента("Узлы");
	Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
		Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента("Узел");
			ЗаписьXML.ЗаписатьАтрибут("Идентификатор", СтрокаСтруктуры.УзелДерева.УникальныйИдентификатор());
			ЗаписьXML.ЗаписатьАтрибут("Наименование", СтрокаСтруктуры.УзелДерева.Наименование);
			Если СтрокаСтруктуры.РодительскийУзел <> Неопределено Тогда
				ЗаписьXML.ЗаписатьАтрибут("Родитель", СтрокаСтруктуры.РодительскийУзел.УникальныйИдентификатор());
			КонецЕсли;
			Если СтрокаСтруктуры.ТипСвязи <> Неопределено Тогда
				ЗаписьXML.ЗаписатьАтрибут("ТипСвязи", Строка(СтрокаСтруктуры.ТипСвязи));
			КонецЕсли;
			ЗаписьXML.ЗаписатьАтрибут("Уровень", Строка(СтрокаСтруктуры.Уровень));
			ЗаписьXML.ЗаписатьАтрибут("ЯвляетсяЛистом", Строка(СтрокаСтруктуры.ЯвляетсяЛистом));
			ЗаписьXML.ЗаписатьКонецЭлемента(); // Узел
		КонецЕсли;
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента(); // Узлы
	ЗаписьXML.ЗаписатьАтрибут("ВремяСохранения", ТекущаяДата());
	ЗаписьXML.ЗаписатьКонецЭлемента(); // ДеревоВопросов
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Восстанавливает дерево вопросов из XML
Процедура ВосстановитьДеревоВопросовИзXML(Тест, XMLДанные) Экспорт
	Если ПустаяСтрока(XMLДанные) Тогда
		Возврат;
	КонецЕсли;
	Попытка
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLДанные);
		Пока ЧтениеXML.Прочитать() Цикл
			Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				Если ЧтениеXML.Имя = "ТекущийУзел" Тогда
					ИдентификаторУзла = ЧтениеXML.ПолучитьАтрибут("Идентификатор");
					Если Не ПустаяСтрока(ИдентификаторУзла) Тогда
						// Находим узел по идентификатору
						Узел = НайтиУзелПоИдентификатору(ИдентификаторУзла);
						Если Узел <> Неопределено Тогда
							Тест.ТекущийУзелДерева = Узел.Ссылка;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		Сообщить("Ошибка при восстановлении дерева из XML: " + ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

// Альтернатива: сохраняем в виде структуры в строке
Функция СформироватьДеревоВопросовСтрока(Тест) Экспорт
	Данные = "";
	// Сохраняем текущий узел
	Если Тест.ТекущийУзелДерева <> Неопределено Тогда
		Данные = Данные + "ТекущийУзел:" + Тест.ТекущийУзелДерева.УникальныйИдентификатор() + ";";
	КонецЕсли;
	// Сохраняем информацию об узлах
	Данные = Данные + "Узлы:";
	Для Каждого СтрокаСтруктуры Из Тест.СтруктураДереваТеста Цикл
		Если СтрокаСтруктуры.УзелДерева <> Неопределено Тогда
			УзелДанные = СтрокаСтруктуры.УзелДерева.УникальныйИдентификатор() + "," +
			СтрокаСтруктуры.УзелДерева.Наименование + "," +
			?(СтрокаСтруктуры.РодительскийУзел = Неопределено, "",
			СтрокаСтруктуры.РодительскийУзел.УникальныйИдентификатор()) + "," +
			?(СтрокаСтруктуры.ТипСвязи = Неопределено, "", СтрокаСтруктуры.ТипСвязи) + "," +
			СтрокаСтруктуры.Уровень + "," +
			СтрокаСтруктуры.ЯвляетсяЛистом + "|";
			Данные = Данные + УзелДанные;
		КонецЕсли;
	КонецЦикла;
	Данные = Данные + ";Время:" + ТекущаяДата() + ";";
	Возврат Данные;
КонецФункции

// Восстанавливает из строки
Процедура ВосстановитьДеревоВопросовИзСтроки(Тест, СтрокаДанных) Экспорт
	Если ПустаяСтрока(СтрокаДанных) Тогда
		Возврат;
	КонецЕсли;
	Попытка
		// Ищем подстроку "ТекущийУзел:" в строке данных
		ПозицияНачала = СтрНайти(СтрокаДанных, "ТекущийУзел:");
		Если ПозицияНачала > 0 Тогда
			// Находим конец идентификатора (до ";")
			ПозицияКонца = СтрНайти(СтрокаДанных, ";", , ПозицияНачала);
			Если ПозицияКонца > 0 Тогда
				// Извлекаем идентификатор текущего узла
				ИдентификаторТекущегоУзла = Сред(СтрокаДанных, ПозицияНачала + 12, ПозицияКонца - ПозицияНачала - 12);
				// Ищем узел по идентификатору
				ТекущийУзел = НайтиУзелПоИдентификатору(ИдентификаторТекущегоУзла);
				Если ТекущийУзел <> Неопределено Тогда
					// Устанавливаем текущий узел дерева
					Тест.ТекущийУзелДерева = ТекущийУзел.Ссылка;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Исключение
		// Выводим сообщение об ошибке с описанием
		Сообщить("Ошибка при восстановлении дерева из строки: " + ОписаниеОшибки(), СтатусСообщения.ОченьВажное);
	КонецПопытки;
КонецПроцедуры

// Диагностическая процедура для проверки данных в регистре
Процедура ПроверитьДанныеВРегистре(ШаблонТеста) Экспорт
	Сообщить("=== ПРОВЕРКА ДАННЫХ В РЕГИСТРЕ ===");
	Сообщить("Шаблон: " + ШаблонТеста.Наименование);
	// Проверяем данные напрямую в регистре
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|    Структура.ШаблонТеста,
	|    Структура.РодительскийУзел,
	|    Структура.ТипОтвета,
	|    Структура.СледующийУзелДерева,
	|    Структура.СостояниеСвязи
	|ИЗ
	|    РегистрСведений.СтруктураБинарногоДерева КАК Структура
	|ГДЕ
	|    Структура.ШаблонТеста = &ШаблонТеста";
	Запрос.УстановитьПараметр("ШаблонТеста", ШаблонТеста);
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	КоличествоЗаписей = 0;
	Сообщить("Записи в регистре:");
	Пока Выборка.Следующий() Цикл
		КоличествоЗаписей = КоличествоЗаписей + 1;
		Сообщить("   " + КоличествоЗаписей + ": " +
		"Шаблон=" + Выборка.ШаблонТеста.Наименование +
		", Родитель=" + ?(Выборка.РодительскийУзел = Неопределено, "КОРЕНЬ", Выборка.РодительскийУзел.Наименование) +
		", ТипОтвета=" + Выборка.ТипОтвета +
		", СледующийУзел=" + ?(Выборка.СледующийУзелДерева = Неопределено, "НЕОПР", Выборка.СледующийУзелДерева.Наименование));
	КонецЦикла;
	Сообщить("Всего записей в регистре: " + КоличествоЗаписей);
КонецПроцедуры

// В модуле ТестированиеБинарноеДерево
Процедура ОчиститьРегистрСостоянияПолностью() Экспорт
    Сообщить("=== ПОЛНАЯ ОЧИСТКА РЕГИСТРА СОСТОЯНИЯ ===");
    
    НаборЗаписей = РегистрыСведений.СостояниеБинарногоДерева.СоздатьНаборЗаписей();
    // Записываем пустой набор - удаляем ВСЕ записи
    НаборЗаписей.Записать();
    
    Сообщить("Регистр состояния полностью очищен");
КонецПроцедуры

// Поместить в общий модуль "ТестированиеБинарноеДерево"
Функция ПолучитьСтатистикуДереваИзРегистра(Шаблон) Экспорт
    
    Результат = Новый Структура("ВсегоУзлов, ЛистовыхУзлов, Глубина");
    Результат.ВсегоУзлов = 0;
    Результат.ЛистовыхУзлов = 0;
    Результат.Глубина = 0;
    
    Запрос = Новый Запрос;
    Запрос.Текст =
    "ВЫБРАТЬ
    |    КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Узлы.Ссылка) КАК ВсегоУзлов,
    |    КОЛИЧЕСТВО(ВЫБОР КОГДА Узлы.ЯвляетсяЛистом ТОГДА Узлы.Ссылка ИНАЧЕ NULL КОНЕЦ) КАК ЛистовыхУзлов,
    |    МАКСИМУМ(Узлы.Уровень) КАК Глубина
    |ИЗ
    |    РегистрСведений.СтруктураБинарногоДерева КАК Структура
    |        ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УзлыБинарногоДерева КАК Узлы
    |        ПО (Структура.РодительскийУзел = Узлы.Ссылка
    |                ИЛИ Структура.СледующийУзелДерева = Узлы.Ссылка)
    |ГДЕ
    |    Структура.ШаблонТеста = &Шаблон";
    
    Запрос.УстановитьПараметр("Шаблон", Шаблон);
    
    Выборка = Запрос.Выполнить().Выбрать();
    Если Выборка.Следующий() Тогда
        Результат.ВсегоУзлов = Выборка.ВсегоУзлов;
        Результат.ЛистовыхУзлов = Выборка.ЛистовыхУзлов;
        // Глубина дерева = максимальный уровень + 1 (т.к. уровни с 0)
        Результат.Глубина = ?(Выборка.Глубина = NULL, 0, Выборка.Глубина + 1);
    КонецЕсли;
    
    Возврат Результат;
    
КонецФункции

#КонецОбласти
                                                              